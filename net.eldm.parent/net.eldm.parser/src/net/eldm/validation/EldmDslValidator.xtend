/*
 * generated by Xtext 2.15.0
 */
package net.eldm.validation

import com.google.inject.Inject
import net.eldm.eldmDsl.EldmDslPackage
import net.eldm.eldmDsl.EnumDef
import net.eldm.eldmDsl.LetValue
import net.eldm.eldmDsl.MapDef
import net.eldm.eldmDsl.MapEntryDef
import net.eldm.eldmDsl.MapLiteral
import net.eldm.eldmDsl.TypeDef
import net.eldm.util.TypeResolver
import net.eldm.util.TypeValidator
import net.eldm.util.ValidationError
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

import static extension net.eldm.util.ValidationStack.*
import java.util.List
import java.util.ArrayList

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EldmDslValidator extends AbstractEldmDslValidator {
  @Inject extension TypeValidator tValidator
  @Inject extension TypeResolver tResolver
  
  def tryValidation(EObject obj, ()=>void tryFunc) {
    try {
      obj.push
        tryFunc.apply
      pop
    } catch (ValidationError err) {
      //err.printStackTrace
      println("COMPILER-ERROR: " + err.message)
      this.error(err.message, err.obj, null)
    } catch (Throwable ex) {
      ex.printStackTrace
    }
  }
  
  def detectRepeatedKey(List<String> list) {
    val detected = new ArrayList<String>
    if (list.length > 1)
      for (i : 0..(list.length - 2))
        for (j : (i+1)..(list.length - 1))
          if (list.get(i) == list.get(j))
            detected.add(list.get(i))
    
    return detected
  }
  
  /*TODO: required validations
   * Verify already existing names for definitions
   * Verify the use of reserved keywords in map and enum entries
  */
  
  @Check
  def void checkLetCase(LetValue it) {
    if (name != name.toLowerCase)
      warning("Incorrect name for let-value! Set all chars to lower-case.", it, EldmDslPackage.Literals.LET_VALUE__NAME)
  }
  
  @Check
  def checkTypeDefCase(TypeDef it) {
    if (parser !== null) {
      if (name != name.toLowerCase)
        warning("Incorrect name for string-type! Set all chars to lower-case.", it, EldmDslPackage.Literals.DEFINITION__NAME)
    } else
      if (name != name.toFirstUpper)
        warning("Incorrect name for structure! Set the first char to upper-case.", it, EldmDslPackage.Literals.DEFINITION__NAME)
  }
  
  @Check
  def void checkKeyDefCase(MapEntryDef it) {
    if (name != name.toLowerCase)
      warning("Incorrect name for key! Set all chars to lower-case.", it, EldmDslPackage.Literals.MAP_ENTRY_DEF__NAME)
  }
  
  @Check
  def void checkMapDefUniqueKeys(MapDef mapDef) {
    val list = mapDef.defs.map[name]
    val keys = list.detectRepeatedKey
    
    if (!keys.empty)
      error('''Multiple keys with the same name [«keys.join(", ")»]''', mapDef, EldmDslPackage.Literals.MAP_DEF__DEFS)
  }
  
  @Check
  def void checkMapLitteralUniqueKeys(MapLiteral mapLit) {
    val list = mapLit.entries.map[name]
    val keys = list.detectRepeatedKey
    
    if (!keys.empty)
      error('''Multiple keys with the same name [«keys.join(", ")»]''', mapLit, EldmDslPackage.Literals.MAP_LITERAL__ENTRIES)
  }
  
  @Check
  def void checkEnumDef(EnumDef ed) {
    if (ed.type === null) {
      ed.defs.forEach[
        if (value !== null)
          error("Enum has no value definition.", it, EldmDslPackage.Literals.ENUM_ITEM_DEF__NAME)
      ]
      
      return
    }
    
    ed.defs.forEach[
      tryValidation[ value.inferType.inElement(ed.type) ]
    ]
  }
  
  @Check
  def void checkLetValue(LetValue it) {
    tryValidation[
      val rType = result.inferType
      rType.inElement(type)
    ]
  }
}
