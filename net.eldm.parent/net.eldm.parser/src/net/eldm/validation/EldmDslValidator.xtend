/*
 * generated by Xtext 2.15.0
 */
package net.eldm.validation

import com.google.inject.Inject
import net.eldm.eldmDsl.EldmDslPackage
import net.eldm.eldmDsl.EnumDef
import net.eldm.eldmDsl.LetValue
import net.eldm.eldmDsl.MapDef
import net.eldm.eldmDsl.MapEntryDef
import net.eldm.eldmDsl.TypeDef
import net.eldm.util.TypeResolver
import net.eldm.util.TypeValidator
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import net.eldm.eldmDsl.MapLiteral

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EldmDslValidator extends AbstractEldmDslValidator {
  @Inject extension TypeValidator tValidator
  @Inject extension TypeResolver tResolver
  
  def error(EObject invalid, String message) {
    val obj = if (invalid.eResource !== null) invalid else invalid.inferredValue
    
    println('''ERROR («obj?.class.simpleName») -> «message»''')
    error(message, obj.eContainer, obj.eContainingFeature)
  }
  
  /*TODO: required validations
   * Verify already existing names for definitions
   * Verify the use of reserved keywords in map and enum entries
  */
  
  @Check
  def void checkLetCase(LetValue it) {
    if (name != name.toLowerCase)
      warning("Incorrect name for let-value! Set all chars to lower-case.", it, EldmDslPackage.Literals.LET_VALUE__NAME)
  }
  
  @Check
  def checkTypeDefCase(TypeDef it) {
    if (parser !== null) {
      if (name != name.toLowerCase)
        warning("Incorrect name for string-type! Set all chars to lower-case.", it, EldmDslPackage.Literals.DEFINITION__NAME)
    } else
      if (name != name.toFirstUpper)
        warning("Incorrect name for structure! Set the first char to upper-case.", it, EldmDslPackage.Literals.DEFINITION__NAME)
  }
  
  @Check
  def void checkKeyDefCase(MapEntryDef it) {
    if (name != name.toLowerCase)
      warning("Incorrect name for key! Set all chars to lower-case.", it, EldmDslPackage.Literals.MAP_ENTRY_DEF__NAME)
  }
  
  @Check
  def void checkMapDefUniqueKeys(MapDef mapDef) {
    if (mapDef.defs.length > 1)
      for (i : 0..mapDef.defs.length) {
        for (j : (i+1)..mapDef.defs.length) {
          if (mapDef.defs.get(i).name == mapDef.defs.get(j).name)
            error("Multiple keys with the same name.", mapDef, EldmDslPackage.Literals.MAP_DEF__DEFS)
            return
        }
      }
  }
  
  @Check
  def void checkMapLitteralUniqueKeys(MapLiteral map) {
    if (map.entries.length > 1)
      for (i : 0..map.entries.length) {
        for (j : (i+1)..map.entries.length) {
          if (map.entries.get(i).name == map.entries.get(j).name)
            error("Multiple keys with the same name.", map, EldmDslPackage.Literals.MAP_LITERAL__ENTRIES)
            return
        }
      }
  }
  
  @Check
  def void checkEnumDef(EnumDef ed) {
    if (ed.type === null) {
      ed.defs.forEach[
        if (value !== null)
          error("Enum has no value definition.", it, EldmDslPackage.Literals.ENUM_ITEM_DEF__NAME)
      ]
      return
    }
      
    ed.defs.forEach[
      if (!value.inferType.inElement(ed.type))
        error("Enum value no assignable to enum type.", it, EldmDslPackage.Literals.ENUM_ITEM_DEF__VALUE)
    ]
  }
  
  @Check
  def void checkLetValue(LetValue it) {
    val rType = result.inferType
    if (rType.inElement(type))
      type = rType // override type specification
    else
      error("ResultExpression not assignable to let type.", it, EldmDslPackage.Literals.LET_VALUE__RESULT)
  }
}
