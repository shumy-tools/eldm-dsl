/*
 * generated by Xtext 2.15.0
 */
package net.eldm.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class EldmDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePathLiteralParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cPlugsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPlugsPlugDslParserRuleCall_3_0 = (RuleCall)cPlugsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cDefinitionsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cDefsAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cDefsDefinitionParserRuleCall_4_2_0 = (RuleCall)cDefsAssignment_4_2.eContents().get(0);
		private final Assignment cVarsAssignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cVarsVarParserRuleCall_4_3_0 = (RuleCall)cVarsAssignment_4_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4_4 = (RuleCall)cGroup_4.eContents().get(4);
		private final Assignment cFuncsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFuncsFunctionParserRuleCall_5_0 = (RuleCall)cFuncsAssignment_5.eContents().get(0);
		private final Assignment cPathsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPathsSubPathParserRuleCall_6_0 = (RuleCall)cPathsAssignment_6.eContents().get(0);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Module Header
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Module:
		//	'module' name=PathLiteral
		//	imports+=Import*
		//	plugs+=PlugDsl* ('definitions:'
		//	BEGIN
		//	defs+=Definition*
		//	vars+=Var*
		//	END)?
		//	funcs+=Function*
		//	paths+=SubPath*;
		@Override public ParserRule getRule() { return rule; }
		
		//'module' name=PathLiteral imports+=Import* plugs+=PlugDsl* ('definitions:' BEGIN defs+=Definition* vars+=Var* END)?
		//funcs+=Function* paths+=SubPath*
		public Group getGroup() { return cGroup; }
		
		//'module'
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_1_0() { return cNamePathLiteralParserRuleCall_1_0; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }
		
		//plugs+=PlugDsl*
		public Assignment getPlugsAssignment_3() { return cPlugsAssignment_3; }
		
		//PlugDsl
		public RuleCall getPlugsPlugDslParserRuleCall_3_0() { return cPlugsPlugDslParserRuleCall_3_0; }
		
		//('definitions:' BEGIN defs+=Definition* vars+=Var* END)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'definitions:'
		public Keyword getDefinitionsKeyword_4_0() { return cDefinitionsKeyword_4_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_4_1() { return cBEGINTerminalRuleCall_4_1; }
		
		//defs+=Definition*
		public Assignment getDefsAssignment_4_2() { return cDefsAssignment_4_2; }
		
		//Definition
		public RuleCall getDefsDefinitionParserRuleCall_4_2_0() { return cDefsDefinitionParserRuleCall_4_2_0; }
		
		//vars+=Var*
		public Assignment getVarsAssignment_4_3() { return cVarsAssignment_4_3; }
		
		//Var
		public RuleCall getVarsVarParserRuleCall_4_3_0() { return cVarsVarParserRuleCall_4_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4_4() { return cENDTerminalRuleCall_4_4; }
		
		//funcs+=Function*
		public Assignment getFuncsAssignment_5() { return cFuncsAssignment_5; }
		
		//Function
		public RuleCall getFuncsFunctionParserRuleCall_5_0() { return cFuncsFunctionParserRuleCall_5_0; }
		
		//paths+=SubPath*
		public Assignment getPathsAssignment_6() { return cPathsAssignment_6; }
		
		//SubPath
		public RuleCall getPathsSubPathParserRuleCall_6_0() { return cPathsSubPathParserRuleCall_6_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cPathAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cPathPathLiteralParserRuleCall_1_0_0 = (RuleCall)cPathAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cDefsAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cDefsExternalDefParserRuleCall_1_1_0_0 = (RuleCall)cDefsAssignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cDefsAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cDefsExternalDefParserRuleCall_1_1_1_1_0 = (RuleCall)cDefsAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cFromKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRefAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefPathLiteralParserRuleCall_3_0 = (RuleCall)cRefAssignment_3.eContents().get(0);
		private final RuleCall cBREAKParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Import:
		//	'import' (path=PathLiteral | defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral BREAK;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' (path=PathLiteral | defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral BREAK
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//path=PathLiteral | defs+=ExternalDef (',' defs+=ExternalDef)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//path=PathLiteral
		public Assignment getPathAssignment_1_0() { return cPathAssignment_1_0; }
		
		//PathLiteral
		public RuleCall getPathPathLiteralParserRuleCall_1_0_0() { return cPathPathLiteralParserRuleCall_1_0_0; }
		
		//defs+=ExternalDef (',' defs+=ExternalDef)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//defs+=ExternalDef
		public Assignment getDefsAssignment_1_1_0() { return cDefsAssignment_1_1_0; }
		
		//ExternalDef
		public RuleCall getDefsExternalDefParserRuleCall_1_1_0_0() { return cDefsExternalDefParserRuleCall_1_1_0_0; }
		
		//(',' defs+=ExternalDef)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }
		
		//','
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }
		
		//defs+=ExternalDef
		public Assignment getDefsAssignment_1_1_1_1() { return cDefsAssignment_1_1_1_1; }
		
		//ExternalDef
		public RuleCall getDefsExternalDefParserRuleCall_1_1_1_1_0() { return cDefsExternalDefParserRuleCall_1_1_1_1_0; }
		
		//'from'
		public Keyword getFromKeyword_2() { return cFromKeyword_2; }
		
		//ref=PathLiteral
		public Assignment getRefAssignment_3() { return cRefAssignment_3; }
		
		//PathLiteral
		public RuleCall getRefPathLiteralParserRuleCall_3_0() { return cRefPathLiteralParserRuleCall_3_0; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_4() { return cBREAKParserRuleCall_4; }
	}
	public class ExternalDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ExternalDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cRefAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cRefIDTerminalRuleCall_0_0_0 = (RuleCall)cRefAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cAsKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cNameAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0_1_1_0 = (RuleCall)cNameAssignment_0_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ExternalDef:
		//	ref=ID ('as' name=ID)? | => name=ID //TODO: check-if is a valid reference to a Definition ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref=ID ('as' name=ID)? | => name=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ref=ID ('as' name=ID)?
		public Group getGroup_0() { return cGroup_0; }
		
		//ref=ID
		public Assignment getRefAssignment_0_0() { return cRefAssignment_0_0; }
		
		//ID
		public RuleCall getRefIDTerminalRuleCall_0_0_0() { return cRefIDTerminalRuleCall_0_0_0; }
		
		//('as' name=ID)?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'as'
		public Keyword getAsKeyword_0_1_0() { return cAsKeyword_0_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_0_1_1() { return cNameAssignment_0_1_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_1_0() { return cNameIDTerminalRuleCall_0_1_1_0; }
		
		//=> name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class PlugDslElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PlugDsl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPlugDslKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cFromKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRefAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefPathLiteralParserRuleCall_3_0 = (RuleCall)cRefAssignment_3.eContents().get(0);
		private final RuleCall cBREAKParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//PlugDsl:
		//	'plug-dsl' name=ID 'from' ref=PathLiteral BREAK;
		@Override public ParserRule getRule() { return rule; }
		
		//'plug-dsl' name=ID 'from' ref=PathLiteral BREAK
		public Group getGroup() { return cGroup; }
		
		//'plug-dsl'
		public Keyword getPlugDslKeyword_0() { return cPlugDslKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'from'
		public Keyword getFromKeyword_2() { return cFromKeyword_2; }
		
		//ref=PathLiteral
		public Assignment getRefAssignment_3() { return cRefAssignment_3; }
		
		//PathLiteral
		public RuleCall getRefPathLiteralParserRuleCall_3_0() { return cRefPathLiteralParserRuleCall_3_0; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_4() { return cBREAKParserRuleCall_4; }
	}
	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDeclAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDeclFuncDeclParserRuleCall_0_0 = (RuleCall)cDeclAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyBlockExpressionParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Operations
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Function:
		//	decl=FuncDecl
		//	body=BlockExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//decl=FuncDecl body=BlockExpression
		public Group getGroup() { return cGroup; }
		
		//decl=FuncDecl
		public Assignment getDeclAssignment_0() { return cDeclAssignment_0; }
		
		//FuncDecl
		public RuleCall getDeclFuncDeclParserRuleCall_0_0() { return cDeclFuncDeclParserRuleCall_0_0; }
		
		//body=BlockExpression
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }
		
		//BlockExpression
		public RuleCall getBodyBlockExpressionParserRuleCall_1_0() { return cBodyBlockExpressionParserRuleCall_1_0; }
	}
	public class FuncDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FuncDecl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cTypeCatchKeyword_0_0_0 = (Keyword)cTypeAssignment_0_0.eContents().get(0);
		private final Assignment cParamAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cParamElementDefParserRuleCall_0_1_0 = (RuleCall)cParamAssignment_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cTypeDefKeyword_1_0_0 = (Keyword)cTypeAssignment_1_0.eContents().get(0);
		private final Assignment cSrvAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cSrvServiceKeyword_1_1_0 = (Keyword)cSrvAssignment_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final Assignment cGetAssignment_1_2_0 = (Assignment)cAlternatives_1_2.eContents().get(0);
		private final Keyword cGetGetKeyword_1_2_0_0 = (Keyword)cGetAssignment_1_2_0.eContents().get(0);
		private final Keyword cSetKeyword_1_2_1 = (Keyword)cAlternatives_1_2.eContents().get(1);
		private final Assignment cPathAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cPathPathLiteralParserRuleCall_1_3_0 = (RuleCall)cPathAssignment_1_3.eContents().get(0);
		private final Assignment cParamAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cParamElementDefParserRuleCall_1_4_0 = (RuleCall)cParamAssignment_1_4.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cGroup_1.eContents().get(5);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_5_0 = (Keyword)cGroup_1_5.eContents().get(0);
		private final Assignment cResultAssignment_1_5_1 = (Assignment)cGroup_1_5.eContents().get(1);
		private final RuleCall cResultElementDefParserRuleCall_1_5_1_0 = (RuleCall)cResultAssignment_1_5_1.eContents().get(0);
		private final Keyword cColonKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		
		//FuncDecl:
		//	type='catch' param=ElementDef? ':'
		//	| type='def' srv?='service'? (get?='get' | 'set') path=PathLiteral? param=ElementDef? ('->' result=ElementDef)? ':';
		@Override public ParserRule getRule() { return rule; }
		
		//type='catch' param=ElementDef? ':' | type='def' srv?='service'? (get?='get' | 'set') path=PathLiteral? param=ElementDef?
		//('->' result=ElementDef)? ':'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//type='catch' param=ElementDef? ':'
		public Group getGroup_0() { return cGroup_0; }
		
		//type='catch'
		public Assignment getTypeAssignment_0_0() { return cTypeAssignment_0_0; }
		
		//'catch'
		public Keyword getTypeCatchKeyword_0_0_0() { return cTypeCatchKeyword_0_0_0; }
		
		//param=ElementDef?
		public Assignment getParamAssignment_0_1() { return cParamAssignment_0_1; }
		
		//ElementDef
		public RuleCall getParamElementDefParserRuleCall_0_1_0() { return cParamElementDefParserRuleCall_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_0_2() { return cColonKeyword_0_2; }
		
		//type='def' srv?='service'? (get?='get' | 'set') path=PathLiteral? param=ElementDef? ('->' result=ElementDef)? ':'
		public Group getGroup_1() { return cGroup_1; }
		
		//type='def'
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//'def'
		public Keyword getTypeDefKeyword_1_0_0() { return cTypeDefKeyword_1_0_0; }
		
		//srv?='service'?
		public Assignment getSrvAssignment_1_1() { return cSrvAssignment_1_1; }
		
		//'service'
		public Keyword getSrvServiceKeyword_1_1_0() { return cSrvServiceKeyword_1_1_0; }
		
		//get?='get' | 'set'
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }
		
		//get?='get'
		public Assignment getGetAssignment_1_2_0() { return cGetAssignment_1_2_0; }
		
		//'get'
		public Keyword getGetGetKeyword_1_2_0_0() { return cGetGetKeyword_1_2_0_0; }
		
		//'set'
		public Keyword getSetKeyword_1_2_1() { return cSetKeyword_1_2_1; }
		
		//path=PathLiteral?
		public Assignment getPathAssignment_1_3() { return cPathAssignment_1_3; }
		
		//PathLiteral
		public RuleCall getPathPathLiteralParserRuleCall_1_3_0() { return cPathPathLiteralParserRuleCall_1_3_0; }
		
		//param=ElementDef?
		public Assignment getParamAssignment_1_4() { return cParamAssignment_1_4; }
		
		//ElementDef
		public RuleCall getParamElementDefParserRuleCall_1_4_0() { return cParamElementDefParserRuleCall_1_4_0; }
		
		//('->' result=ElementDef)?
		public Group getGroup_1_5() { return cGroup_1_5; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_5_0() { return cHyphenMinusGreaterThanSignKeyword_1_5_0; }
		
		//result=ElementDef
		public Assignment getResultAssignment_1_5_1() { return cResultAssignment_1_5_1; }
		
		//ElementDef
		public RuleCall getResultElementDefParserRuleCall_1_5_1_0() { return cResultElementDefParserRuleCall_1_5_1_0; }
		
		//':'
		public Keyword getColonKeyword_1_6() { return cColonKeyword_1_6; }
	}
	public class SubPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.SubPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathPathLiteralParserRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cFuncsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFuncsFunctionParserRuleCall_3_0 = (RuleCall)cFuncsAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//SubPath:
		//	'def' path=PathLiteral
		//	BEGIN
		//	funcs+=Function+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'def' path=PathLiteral BEGIN funcs+=Function+ END
		public Group getGroup() { return cGroup; }
		
		//'def'
		public Keyword getDefKeyword_0() { return cDefKeyword_0; }
		
		//path=PathLiteral
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }
		
		//PathLiteral
		public RuleCall getPathPathLiteralParserRuleCall_1_0() { return cPathPathLiteralParserRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//funcs+=Function+
		public Assignment getFuncsAssignment_3() { return cFuncsAssignment_3; }
		
		//Function
		public RuleCall getFuncsFunctionParserRuleCall_3_0() { return cFuncsFunctionParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class BlockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BlockExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Expressions
		//// ------------------------------------------------------------------------------------------------------------------------------
		//BlockExpression:
		//	{BlockExpression} BEGIN
		//	expressions+=Expression*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{BlockExpression} BEGIN expressions+=Expression* END
		public Group getGroup() { return cGroup; }
		
		//{BlockExpression}
		public Action getBlockExpressionAction_0() { return cBlockExpressionAction_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1() { return cBEGINTerminalRuleCall_1; }
		
		//expressions+=Expression*
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_0() { return cExpressionsExpressionParserRuleCall_2_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_3() { return cENDTerminalRuleCall_3; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Expression");
		private final RuleCall cIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Identifier;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO: add more expressions?
		//Identifier
		public RuleCall getIdentifierParserRuleCall() { return cIdentifierParserRuleCall; }
	}
	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Identifier");
		private final RuleCall cVarParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Identifier:
		//	Var // | Param
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Var
		public RuleCall getVarParserRuleCall() { return cVarParserRuleCall; }
	}
	public class VarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Var");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cLetAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cLetLetKeyword_0_0_0 = (Keyword)cLetAssignment_0_0.eContents().get(0);
		private final Keyword cVarKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cResultAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cResultValueExpressionParserRuleCall_4_0 = (RuleCall)cResultAssignment_4.eContents().get(0);
		
		//Var:
		//	(let?='let' | 'var') name=ID (':' type=ElementDef)? '=' result=ValueExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//(let?='let' | 'var') name=ID (':' type=ElementDef)? '=' result=ValueExpression
		public Group getGroup() { return cGroup; }
		
		//let?='let' | 'var'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//let?='let'
		public Assignment getLetAssignment_0_0() { return cLetAssignment_0_0; }
		
		//'let'
		public Keyword getLetLetKeyword_0_0_0() { return cLetLetKeyword_0_0_0; }
		
		//'var'
		public Keyword getVarKeyword_0_1() { return cVarKeyword_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(':' type=ElementDef)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_1_0() { return cTypeElementDefParserRuleCall_2_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//result=ValueExpression
		public Assignment getResultAssignment_4() { return cResultAssignment_4; }
		
		//ValueExpression
		public RuleCall getResultValueExpressionParserRuleCall_4_0() { return cResultValueExpressionParserRuleCall_4_0; }
	}
	public class ValueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ValueExpression");
		private final RuleCall cOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// the result expression must be equivalent to an immutable Literal
		//ValueExpression:
		//	OrExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall() { return cOrExpressionParserRuleCall; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cValueExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cFeatureOrKeyword_1_0_0_1_0 = (Keyword)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//OrExpression ValueExpression:
		//	AndExpression (=> ({ValueExpression.left=current} feature='or') right=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression (=> ({ValueExpression.left=current} feature='or') right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//(=> ({ValueExpression.left=current} feature='or') right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ValueExpression.left=current} feature='or')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ValueExpression.left=current} feature='or'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ValueExpression.left=current}
		public Action getValueExpressionLeftAction_1_0_0_0() { return cValueExpressionLeftAction_1_0_0_0; }
		
		//feature='or'
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//'or'
		public Keyword getFeatureOrKeyword_1_0_0_1_0() { return cFeatureOrKeyword_1_0_0_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_1_0() { return cRightAndExpressionParserRuleCall_1_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cValueExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cFeatureAndKeyword_1_0_0_1_0 = (Keyword)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEqualityExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AndExpression ValueExpression:
		//	EqualityExpression (=> ({ValueExpression.left=current} feature='and') right=EqualityExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//EqualityExpression (=> ({ValueExpression.left=current} feature='and') right=EqualityExpression)*
		public Group getGroup() { return cGroup; }
		
		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }
		
		//(=> ({ValueExpression.left=current} feature='and') right=EqualityExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ValueExpression.left=current} feature='and')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ValueExpression.left=current} feature='and'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ValueExpression.left=current}
		public Action getValueExpressionLeftAction_1_0_0_0() { return cValueExpressionLeftAction_1_0_0_0; }
		
		//feature='and'
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//'and'
		public Keyword getFeatureAndKeyword_1_0_0_1_0() { return cFeatureAndKeyword_1_0_0_1_0; }
		
		//right=EqualityExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//EqualityExpression
		public RuleCall getRightEqualityExpressionParserRuleCall_1_1_0() { return cRightEqualityExpressionParserRuleCall_1_1_0; }
	}
	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cValueExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cFeatureEqualsSignEqualsSignKeyword_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureExclamationMarkEqualsSignKeyword_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//EqualityExpression ValueExpression:
		//	RelationalExpression (=> ({ValueExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//RelationalExpression (=> ({ValueExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }
		
		//(=> ({ValueExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ValueExpression.left=current} feature=('==' | '!='))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ValueExpression.left=current} feature=('==' | '!=')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ValueExpression.left=current}
		public Action getValueExpressionLeftAction_1_0_0_0() { return cValueExpressionLeftAction_1_0_0_0; }
		
		//feature=('==' | '!=')
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//('==' | '!=')
		public Alternatives getFeatureAlternatives_1_0_0_1_0() { return cFeatureAlternatives_1_0_0_1_0; }
		
		//'=='
		public Keyword getFeatureEqualsSignEqualsSignKeyword_1_0_0_1_0_0() { return cFeatureEqualsSignEqualsSignKeyword_1_0_0_1_0_0; }
		
		//'!='
		public Keyword getFeatureExclamationMarkEqualsSignKeyword_1_0_0_1_0_1() { return cFeatureExclamationMarkEqualsSignKeyword_1_0_0_1_0_1; }
		
		//right=RelationalExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//RelationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_1_0() { return cRightRelationalExpressionParserRuleCall_1_1_0; }
	}
	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cGroup_1_0_0.eContents().get(0);
		private final Action cIsExpressionLeftAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_0_1 = (Assignment)cGroup_1_0_0_0.eContents().get(1);
		private final Keyword cFeatureIsKeyword_1_0_0_0_1_0 = (Keyword)cFeatureAssignment_1_0_0_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_1_0_1_0 = (RuleCall)cTypeAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_0_0 = (Group)cGroup_1_1_0.eContents().get(0);
		private final Action cValueExpressionLeftAction_1_1_0_0_0 = (Action)cGroup_1_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_1_0_0_1 = (Assignment)cGroup_1_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_1_0_0_1.eContents().get(0);
		private final Keyword cFeatureGreaterThanSignEqualsSignKeyword_1_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureLessThanSignEqualsSignKeyword_1_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(1);
		private final Keyword cFeatureGreaterThanSignKeyword_1_1_0_0_1_0_2 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(2);
		private final Keyword cFeatureLessThanSignKeyword_1_1_0_0_1_0_3 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRightAssignment_1_1_1.eContents().get(0);
		
		//RelationalExpression ValueExpression:
		//	AdditiveExpression (=> ({IsExpression.left=current} feature='is') type=ElementDef
		//	| => ({ValueExpression.left=current} feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AdditiveExpression (=> ({IsExpression.left=current} feature='is') type=ElementDef | => ({ValueExpression.left=current}
		//feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*
		public Group getGroup() { return cGroup; }
		
		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }
		
		//(=> ({IsExpression.left=current} feature='is') type=ElementDef | => ({ValueExpression.left=current} feature=('>=' | '<='
		//| '>' | '<')) right=AdditiveExpression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//=> ({IsExpression.left=current} feature='is') type=ElementDef
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//=> ({IsExpression.left=current} feature='is')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{IsExpression.left=current} feature='is'
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }
		
		//{IsExpression.left=current}
		public Action getIsExpressionLeftAction_1_0_0_0_0() { return cIsExpressionLeftAction_1_0_0_0_0; }
		
		//feature='is'
		public Assignment getFeatureAssignment_1_0_0_0_1() { return cFeatureAssignment_1_0_0_0_1; }
		
		//'is'
		public Keyword getFeatureIsKeyword_1_0_0_0_1_0() { return cFeatureIsKeyword_1_0_0_0_1_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_1_0_1() { return cTypeAssignment_1_0_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_1_0_1_0() { return cTypeElementDefParserRuleCall_1_0_1_0; }
		
		//=> ({ValueExpression.left=current} feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//=> ({ValueExpression.left=current} feature=('>=' | '<=' | '>' | '<'))
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }
		
		//{ValueExpression.left=current} feature=('>=' | '<=' | '>' | '<')
		public Group getGroup_1_1_0_0() { return cGroup_1_1_0_0; }
		
		//{ValueExpression.left=current}
		public Action getValueExpressionLeftAction_1_1_0_0_0() { return cValueExpressionLeftAction_1_1_0_0_0; }
		
		//feature=('>=' | '<=' | '>' | '<')
		public Assignment getFeatureAssignment_1_1_0_0_1() { return cFeatureAssignment_1_1_0_0_1; }
		
		//('>=' | '<=' | '>' | '<')
		public Alternatives getFeatureAlternatives_1_1_0_0_1_0() { return cFeatureAlternatives_1_1_0_0_1_0; }
		
		//'>='
		public Keyword getFeatureGreaterThanSignEqualsSignKeyword_1_1_0_0_1_0_0() { return cFeatureGreaterThanSignEqualsSignKeyword_1_1_0_0_1_0_0; }
		
		//'<='
		public Keyword getFeatureLessThanSignEqualsSignKeyword_1_1_0_0_1_0_1() { return cFeatureLessThanSignEqualsSignKeyword_1_1_0_0_1_0_1; }
		
		//'>'
		public Keyword getFeatureGreaterThanSignKeyword_1_1_0_0_1_0_2() { return cFeatureGreaterThanSignKeyword_1_1_0_0_1_0_2; }
		
		//'<'
		public Keyword getFeatureLessThanSignKeyword_1_1_0_0_1_0_3() { return cFeatureLessThanSignKeyword_1_1_0_0_1_0_3; }
		
		//right=AdditiveExpression
		public Assignment getRightAssignment_1_1_1() { return cRightAssignment_1_1_1; }
		
		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_1_1_0() { return cRightAdditiveExpressionParserRuleCall_1_1_1_0; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cValueExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cFeaturePlusSignKeyword_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureHyphenMinusKeyword_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(1);
		private final Keyword cFeatureSetKeyword_1_0_0_1_0_2 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(2);
		private final Keyword cFeatureDelKeyword_1_0_0_1_0_3 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AdditiveExpression ValueExpression:
		//	MultiplicativeExpression (=> ({ValueExpression.left=current} feature=('+' | '-' | 'set' | 'del'))
		//	right=MultiplicativeExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression (=> ({ValueExpression.left=current} feature=('+' | '-' | 'set' | 'del'))
		//right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//(=> ({ValueExpression.left=current} feature=('+' | '-' | 'set' | 'del')) right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ValueExpression.left=current} feature=('+' | '-' | 'set' | 'del'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ValueExpression.left=current} feature=('+' | '-' | 'set' | 'del')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ValueExpression.left=current}
		public Action getValueExpressionLeftAction_1_0_0_0() { return cValueExpressionLeftAction_1_0_0_0; }
		
		//feature=('+' | '-' | 'set' | 'del')
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//('+' | '-' | 'set' | 'del')
		public Alternatives getFeatureAlternatives_1_0_0_1_0() { return cFeatureAlternatives_1_0_0_1_0; }
		
		//'+'
		public Keyword getFeaturePlusSignKeyword_1_0_0_1_0_0() { return cFeaturePlusSignKeyword_1_0_0_1_0_0; }
		
		//'-'
		public Keyword getFeatureHyphenMinusKeyword_1_0_0_1_0_1() { return cFeatureHyphenMinusKeyword_1_0_0_1_0_1; }
		
		//'set'
		public Keyword getFeatureSetKeyword_1_0_0_1_0_2() { return cFeatureSetKeyword_1_0_0_1_0_2; }
		
		//'del'
		public Keyword getFeatureDelKeyword_1_0_0_1_0_3() { return cFeatureDelKeyword_1_0_0_1_0_3; }
		
		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_1_0() { return cRightMultiplicativeExpressionParserRuleCall_1_1_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cValueExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cFeatureAsteriskKeyword_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureAsteriskAsteriskKeyword_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(1);
		private final Keyword cFeatureSolidusKeyword_1_0_0_1_0_2 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(2);
		private final Keyword cFeaturePercentSignKeyword_1_0_0_1_0_3 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryOperationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MultiplicativeExpression ValueExpression:
		//	UnaryOperation (=> ({ValueExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*;
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryOperation (=> ({ValueExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*
		public Group getGroup() { return cGroup; }
		
		//UnaryOperation
		public RuleCall getUnaryOperationParserRuleCall_0() { return cUnaryOperationParserRuleCall_0; }
		
		//(=> ({ValueExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ValueExpression.left=current} feature=('*' | '**' | '/' | '%'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ValueExpression.left=current} feature=('*' | '**' | '/' | '%')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ValueExpression.left=current}
		public Action getValueExpressionLeftAction_1_0_0_0() { return cValueExpressionLeftAction_1_0_0_0; }
		
		//feature=('*' | '**' | '/' | '%')
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//('*' | '**' | '/' | '%')
		public Alternatives getFeatureAlternatives_1_0_0_1_0() { return cFeatureAlternatives_1_0_0_1_0; }
		
		//'*'
		public Keyword getFeatureAsteriskKeyword_1_0_0_1_0_0() { return cFeatureAsteriskKeyword_1_0_0_1_0_0; }
		
		//'**'
		public Keyword getFeatureAsteriskAsteriskKeyword_1_0_0_1_0_1() { return cFeatureAsteriskAsteriskKeyword_1_0_0_1_0_1; }
		
		//'/'
		public Keyword getFeatureSolidusKeyword_1_0_0_1_0_2() { return cFeatureSolidusKeyword_1_0_0_1_0_2; }
		
		//'%'
		public Keyword getFeaturePercentSignKeyword_1_0_0_1_0_3() { return cFeaturePercentSignKeyword_1_0_0_1_0_3; }
		
		//right=UnaryOperation
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//UnaryOperation
		public RuleCall getRightUnaryOperationParserRuleCall_1_1_0() { return cRightUnaryOperationParserRuleCall_1_1_0; }
	}
	public class UnaryOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.UnaryOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryOperationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cFeatureAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cFeatureExclamationMarkKeyword_0_1_0 = (Keyword)cFeatureAssignment_0_1.eContents().get(0);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandUnaryOperationParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final RuleCall cBaseExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// UnaryOperation -> (feature operand)
		//UnaryOperation ValueExpression:
		//	{UnaryOperation} feature='!' operand=UnaryOperation | BaseExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//{UnaryOperation} feature='!' operand=UnaryOperation | BaseExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{UnaryOperation} feature='!' operand=UnaryOperation
		public Group getGroup_0() { return cGroup_0; }
		
		//{UnaryOperation}
		public Action getUnaryOperationAction_0_0() { return cUnaryOperationAction_0_0; }
		
		//feature='!'
		public Assignment getFeatureAssignment_0_1() { return cFeatureAssignment_0_1; }
		
		//'!'
		public Keyword getFeatureExclamationMarkKeyword_0_1_0() { return cFeatureExclamationMarkKeyword_0_1_0; }
		
		//operand=UnaryOperation
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//UnaryOperation
		public RuleCall getOperandUnaryOperationParserRuleCall_0_2_0() { return cOperandUnaryOperationParserRuleCall_0_2_0; }
		
		//BaseExpression
		public RuleCall getBaseExpressionParserRuleCall_1() { return cBaseExpressionParserRuleCall_1; }
	}
	public class BaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BaseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cValueExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BaseExpression ValueExpression:
		//	Primary | '(' ValueExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//Primary | '(' ValueExpression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//'(' ValueExpression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//ValueExpression
		public RuleCall getValueExpressionParserRuleCall_1_1() { return cValueExpressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Primary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cLeftPointingDoubleAngleQuotationMarkKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Keyword cRightPointingDoubleAngleQuotationMarkKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cValueLiteralParserRuleCall_1_0_0 = (RuleCall)cValueAssignment_1_0.eContents().get(0);
		private final Assignment cRefAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cRefIDTerminalRuleCall_1_1_0 = (RuleCall)cRefAssignment_1_1.eContents().get(0);
		private final Assignment cCallsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCallsMemberCallParserRuleCall_2_0 = (RuleCall)cCallsAssignment_2.eContents().get(0);
		
		//Primary:
		//	('«' type=ElementDef '»')? (value=Literal | ref=ID) calls+=MemberCall*;
		@Override public ParserRule getRule() { return rule; }
		
		//('«' type=ElementDef '»')? (value=Literal | ref=ID) calls+=MemberCall*
		public Group getGroup() { return cGroup; }
		
		//('«' type=ElementDef '»')?
		public Group getGroup_0() { return cGroup_0; }
		
		//'«'
		public Keyword getLeftPointingDoubleAngleQuotationMarkKeyword_0_0() { return cLeftPointingDoubleAngleQuotationMarkKeyword_0_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_0_1_0() { return cTypeElementDefParserRuleCall_0_1_0; }
		
		//'»'
		public Keyword getRightPointingDoubleAngleQuotationMarkKeyword_0_2() { return cRightPointingDoubleAngleQuotationMarkKeyword_0_2; }
		
		//value=Literal | ref=ID
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//value=Literal
		public Assignment getValueAssignment_1_0() { return cValueAssignment_1_0; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_0_0() { return cValueLiteralParserRuleCall_1_0_0; }
		
		//ref=ID
		public Assignment getRefAssignment_1_1() { return cRefAssignment_1_1; }
		
		//ID
		public RuleCall getRefIDTerminalRuleCall_1_1_0() { return cRefIDTerminalRuleCall_1_1_0; }
		
		//calls+=MemberCall*
		public Assignment getCallsAssignment_2() { return cCallsAssignment_2; }
		
		//MemberCall
		public RuleCall getCallsMemberCallParserRuleCall_2_0() { return cCallsMemberCallParserRuleCall_2_0; }
	}
	public class MemberCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MemberCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Assignment cNullSafeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cNullSafeQuestionMarkFullStopKeyword_0_1_0 = (Keyword)cNullSafeAssignment_0_1.eContents().get(0);
		private final Assignment cMemberAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMemberIDTerminalRuleCall_1_0 = (RuleCall)cMemberAssignment_1.eContents().get(0);
		
		//MemberCall:
		//	('.' | nullSafe?='?.') member=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//('.' | nullSafe?='?.') member=ID
		public Group getGroup() { return cGroup; }
		
		//'.' | nullSafe?='?.'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//nullSafe?='?.'
		public Assignment getNullSafeAssignment_0_1() { return cNullSafeAssignment_0_1; }
		
		//'?.'
		public Keyword getNullSafeQuestionMarkFullStopKeyword_0_1_0() { return cNullSafeQuestionMarkFullStopKeyword_0_1_0; }
		
		//member=ID
		public Assignment getMemberAssignment_1() { return cMemberAssignment_1; }
		
		//ID
		public RuleCall getMemberIDTerminalRuleCall_1_0() { return cMemberIDTerminalRuleCall_1_0; }
	}
	public class DefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeDefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExternalDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///*
		//OperationCall:
		//  async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression
		//;
		//
		//PostfixOperation returns ResultExpression:
		//  BaseExpression =>({UnaryOperation.operand=current} feature=('++'|'--'))?
		//;
		//* */ // ------------------------------------------------------------------------------------------------------------------------------
		//// Type Definitions
		//// ------------------------------------------------------------------------------------------------------------------------------
		///*LambdaDef:
		//  '#(' param=ElementDef ('->' result=ElementDef)? ')'
		//;*/ Definition:
		//	TypeDef | ExternalDef;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeDef | ExternalDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TypeDef
		public RuleCall getTypeDefParserRuleCall_0() { return cTypeDefParserRuleCall_0; }
		
		//ExternalDef
		public RuleCall getExternalDefParserRuleCall_1() { return cExternalDefParserRuleCall_1; }
	}
	public class TypeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TypeDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypedefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cParserAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final Alternatives cParserAlternatives_2_0_0_0 = (Alternatives)cParserAssignment_2_0_0.eContents().get(0);
		private final Keyword cParserMatchKeyword_2_0_0_0_0 = (Keyword)cParserAlternatives_2_0_0_0.eContents().get(0);
		private final Keyword cParserMaskKeyword_2_0_0_0_1 = (Keyword)cParserAlternatives_2_0_0_0.eContents().get(1);
		private final Assignment cCodeAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cCodeTEXTTerminalRuleCall_2_0_1_0 = (RuleCall)cCodeAssignment_2_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cTypeTopDefParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		
		//TypeDef:
		//	'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=TopDef);
		@Override public ParserRule getRule() { return rule; }
		
		//'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=TopDef)
		public Group getGroup() { return cGroup; }
		
		//'typedef'
		public Keyword getTypedefKeyword_0() { return cTypedefKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//parser=('match' | 'mask') code=TEXT | type=TopDef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//parser=('match' | 'mask') code=TEXT
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//parser=('match' | 'mask')
		public Assignment getParserAssignment_2_0_0() { return cParserAssignment_2_0_0; }
		
		//('match' | 'mask')
		public Alternatives getParserAlternatives_2_0_0_0() { return cParserAlternatives_2_0_0_0; }
		
		//'match'
		public Keyword getParserMatchKeyword_2_0_0_0_0() { return cParserMatchKeyword_2_0_0_0_0; }
		
		//'mask'
		public Keyword getParserMaskKeyword_2_0_0_0_1() { return cParserMaskKeyword_2_0_0_0_1; }
		
		//code=TEXT
		public Assignment getCodeAssignment_2_0_1() { return cCodeAssignment_2_0_1; }
		
		//TEXT
		public RuleCall getCodeTEXTTerminalRuleCall_2_0_1_0() { return cCodeTEXTTerminalRuleCall_2_0_1_0; }
		
		//type=TopDef
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//TopDef
		public RuleCall getTypeTopDefParserRuleCall_2_1_0() { return cTypeTopDefParserRuleCall_2_1_0; }
	}
	public class TopDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TopDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cElementDefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TopDef:
		//	ElementDef | EnumDef;
		@Override public ParserRule getRule() { return rule; }
		
		//ElementDef | EnumDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ElementDef
		public RuleCall getElementDefParserRuleCall_0() { return cElementDefParserRuleCall_0; }
		
		//EnumDef
		public RuleCall getEnumDefParserRuleCall_1() { return cEnumDefParserRuleCall_1; }
	}
	public class ElementDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ElementDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNativeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNativeNativeDefParserRuleCall_0_0 = (RuleCall)cNativeAssignment_0.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cRefDefinitionCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefDefinitionIDTerminalRuleCall_1_0_1 = (RuleCall)cRefDefinitionCrossReference_1_0.eContents().get(1);
		private final RuleCall cListDefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMapDefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ElementDef:
		//	native=NativeDef
		//	| ref=[Definition] | ListDef
		//	| MapDef;
		@Override public ParserRule getRule() { return rule; }
		
		//native=NativeDef | ref=[Definition] | ListDef | MapDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//native=NativeDef
		public Assignment getNativeAssignment_0() { return cNativeAssignment_0; }
		
		//NativeDef
		public RuleCall getNativeNativeDefParserRuleCall_0_0() { return cNativeNativeDefParserRuleCall_0_0; }
		
		//ref=[Definition]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }
		
		//[Definition]
		public CrossReference getRefDefinitionCrossReference_1_0() { return cRefDefinitionCrossReference_1_0; }
		
		//ID
		public RuleCall getRefDefinitionIDTerminalRuleCall_1_0_1() { return cRefDefinitionIDTerminalRuleCall_1_0_1; }
		
		//ListDef
		public RuleCall getListDefParserRuleCall_2() { return cListDefParserRuleCall_2; }
		
		//MapDef
		public RuleCall getMapDefParserRuleCall_3() { return cMapDefParserRuleCall_3; }
	}
	public class MapDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Action cMapDefAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Assignment cDefsAssignment_0_0_2_0 = (Assignment)cGroup_0_0_2.eContents().get(0);
		private final RuleCall cDefsMapEntryDefParserRuleCall_0_0_2_0_0 = (RuleCall)cDefsAssignment_0_0_2_0.eContents().get(0);
		private final Group cGroup_0_0_2_1 = (Group)cGroup_0_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_0_0_2_1_0 = (Keyword)cGroup_0_0_2_1.eContents().get(0);
		private final Assignment cDefsAssignment_0_0_2_1_1 = (Assignment)cGroup_0_0_2_1.eContents().get(1);
		private final RuleCall cDefsMapEntryDefParserRuleCall_0_0_2_1_1_0 = (RuleCall)cDefsAssignment_0_0_2_1_1.eContents().get(0);
		private final Group cGroup_0_0_3 = (Group)cGroup_0_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_0_3_0 = (Keyword)cGroup_0_0_3.eContents().get(0);
		private final Assignment cExtAssignment_0_0_3_1 = (Assignment)cGroup_0_0_3.eContents().get(1);
		private final Keyword cExtAsteriskKeyword_0_0_3_1_0 = (Keyword)cExtAssignment_0_0_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_0_4 = (Keyword)cGroup_0_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMapDefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cDefsAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cDefsMapEntryDefParserRuleCall_1_3_0_0 = (RuleCall)cDefsAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final Keyword cCommaKeyword_1_3_1_0 = (Keyword)cGroup_1_3_1.eContents().get(0);
		private final RuleCall cBREAKParserRuleCall_1_3_1_1 = (RuleCall)cGroup_1_3_1.eContents().get(1);
		private final Assignment cDefsAssignment_1_3_1_2 = (Assignment)cGroup_1_3_1.eContents().get(2);
		private final RuleCall cDefsMapEntryDefParserRuleCall_1_3_1_2_0 = (RuleCall)cDefsAssignment_1_3_1_2.eContents().get(0);
		private final Assignment cExtAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final Keyword cExtAsteriskKeyword_1_4_0 = (Keyword)cExtAssignment_1_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_1_5 = (RuleCall)cGroup_1.eContents().get(5);
		private final Keyword cRightCurlyBracketKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		
		//MapDef:
		//	=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? (',' ext?='*')? '}') | {MapDef} '{'
		//	BEGIN (defs+=MapEntryDef (','? BREAK defs+=MapEntryDef)*)?
		//	ext?='*'?
		//	END
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? (',' ext?='*')? '}') | {MapDef} '{' BEGIN
		//(defs+=MapEntryDef (','? BREAK defs+=MapEntryDef)*)? ext?='*'? END '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? (',' ext?='*')? '}')
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? (',' ext?='*')? '}'
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//{MapDef}
		public Action getMapDefAction_0_0_0() { return cMapDefAction_0_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0_1() { return cLeftCurlyBracketKeyword_0_0_1; }
		
		//(defs+=MapEntryDef (',' defs+=MapEntryDef)*)?
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_0_0_2_0() { return cDefsAssignment_0_0_2_0; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_0_0_2_0_0() { return cDefsMapEntryDefParserRuleCall_0_0_2_0_0; }
		
		//(',' defs+=MapEntryDef)*
		public Group getGroup_0_0_2_1() { return cGroup_0_0_2_1; }
		
		//','
		public Keyword getCommaKeyword_0_0_2_1_0() { return cCommaKeyword_0_0_2_1_0; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_0_0_2_1_1() { return cDefsAssignment_0_0_2_1_1; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_0_0_2_1_1_0() { return cDefsMapEntryDefParserRuleCall_0_0_2_1_1_0; }
		
		//(',' ext?='*')?
		public Group getGroup_0_0_3() { return cGroup_0_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_0_3_0() { return cCommaKeyword_0_0_3_0; }
		
		//ext?='*'
		public Assignment getExtAssignment_0_0_3_1() { return cExtAssignment_0_0_3_1; }
		
		//'*'
		public Keyword getExtAsteriskKeyword_0_0_3_1_0() { return cExtAsteriskKeyword_0_0_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_0_4() { return cRightCurlyBracketKeyword_0_0_4; }
		
		//{MapDef} '{' BEGIN (defs+=MapEntryDef (','? BREAK defs+=MapEntryDef)*)? ext?='*'? END '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//{MapDef}
		public Action getMapDefAction_1_0() { return cMapDefAction_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1_2() { return cBEGINTerminalRuleCall_1_2; }
		
		//(defs+=MapEntryDef (','? BREAK defs+=MapEntryDef)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_1_3_0() { return cDefsAssignment_1_3_0; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_1_3_0_0() { return cDefsMapEntryDefParserRuleCall_1_3_0_0; }
		
		//(','? BREAK defs+=MapEntryDef)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }
		
		//','?
		public Keyword getCommaKeyword_1_3_1_0() { return cCommaKeyword_1_3_1_0; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_1_3_1_1() { return cBREAKParserRuleCall_1_3_1_1; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_1_3_1_2() { return cDefsAssignment_1_3_1_2; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_1_3_1_2_0() { return cDefsMapEntryDefParserRuleCall_1_3_1_2_0; }
		
		//ext?='*'?
		public Assignment getExtAssignment_1_4() { return cExtAssignment_1_4; }
		
		//'*'
		public Keyword getExtAsteriskKeyword_1_4_0() { return cExtAsteriskKeyword_1_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_1_5() { return cENDTerminalRuleCall_1_5; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_6() { return cRightCurlyBracketKeyword_1_6; }
	}
	public class MapEntryDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapEntryDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cOptAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final Keyword cOptQuestionMarkKeyword_1_0_0_0 = (Keyword)cOptAssignment_1_0_0.eContents().get(0);
		private final Keyword cColonKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cTypeElementDefParserRuleCall_1_0_2_0 = (RuleCall)cTypeAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cOptAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final Keyword cOptEqualsSignKeyword_1_1_0_0 = (Keyword)cOptAssignment_1_1_0.eContents().get(0);
		private final Assignment cValueAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_1_1_0 = (RuleCall)cValueAssignment_1_1_1.eContents().get(0);
		
		//MapEntryDef:
		//	name=ID (opt?='?'? ':' type=ElementDef | opt?='=' value=Literal)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID (opt?='?'? ':' type=ElementDef | opt?='=' value=Literal)?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//(opt?='?'? ':' type=ElementDef | opt?='=' value=Literal)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//opt?='?'? ':' type=ElementDef
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//opt?='?'?
		public Assignment getOptAssignment_1_0_0() { return cOptAssignment_1_0_0; }
		
		//'?'
		public Keyword getOptQuestionMarkKeyword_1_0_0_0() { return cOptQuestionMarkKeyword_1_0_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_0_1() { return cColonKeyword_1_0_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_1_0_2() { return cTypeAssignment_1_0_2; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_1_0_2_0() { return cTypeElementDefParserRuleCall_1_0_2_0; }
		
		//opt?='=' value=Literal
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//opt?='='
		public Assignment getOptAssignment_1_1_0() { return cOptAssignment_1_1_0; }
		
		//'='
		public Keyword getOptEqualsSignKeyword_1_1_0_0() { return cOptEqualsSignKeyword_1_1_0_0; }
		
		//value=Literal
		public Assignment getValueAssignment_1_1_1() { return cValueAssignment_1_1_1; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_1_1_0() { return cValueLiteralParserRuleCall_1_1_1_0; }
	}
	public class ListDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ListDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListDefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeElementDefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//ListDef:
		//	{ListDef}
		//	'..' type=ElementDef;
		@Override public ParserRule getRule() { return rule; }
		
		//{ListDef} '..' type=ElementDef
		public Group getGroup() { return cGroup; }
		
		//{ListDef}
		public Action getListDefAction_0() { return cListDefAction_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_0() { return cTypeElementDefParserRuleCall_2_0; }
	}
	public class EnumDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeMapDefParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cDefsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDefsEnumItemDefParserRuleCall_4_0 = (RuleCall)cDefsAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//EnumDef:
		//	'enum' type=MapDef? ':'
		//	BEGIN
		//	defs+=EnumItemDef+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' type=MapDef? ':' BEGIN defs+=EnumItemDef+ END
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//type=MapDef?
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//MapDef
		public RuleCall getTypeMapDefParserRuleCall_1_0() { return cTypeMapDefParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//defs+=EnumItemDef+
		public Assignment getDefsAssignment_4() { return cDefsAssignment_4; }
		
		//EnumItemDef
		public RuleCall getDefsEnumItemDefParserRuleCall_4_0() { return cDefsEnumItemDefParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class EnumItemDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumItemDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueMapLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//EnumItemDef:
		//	name=ID value=MapLiteral?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID value=MapLiteral?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//value=MapLiteral?
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//MapLiteral
		public RuleCall getValueMapLiteralParserRuleCall_1_0() { return cValueMapLiteralParserRuleCall_1_0; }
	}
	public class NativeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.NativeDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAnyKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPathKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBoolKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cStrKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cIntKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFltKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLdaKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLtmKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLdtKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMapKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLstKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cEnumKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		//NativeDef:
		//	'any' | 'path'
		//	| 'bool' | 'str' | 'int' | 'flt'
		//	| 'lda' | 'ltm' | 'ldt'
		//	| 'map' | 'lst' | 'enum';
		@Override public ParserRule getRule() { return rule; }
		
		//'any' | 'path' | 'bool' | 'str' | 'int' | 'flt' | 'lda' | 'ltm' | 'ldt' | 'map' | 'lst' | 'enum'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'any'
		public Keyword getAnyKeyword_0() { return cAnyKeyword_0; }
		
		//'path'
		public Keyword getPathKeyword_1() { return cPathKeyword_1; }
		
		//'bool'
		public Keyword getBoolKeyword_2() { return cBoolKeyword_2; }
		
		//'str'
		public Keyword getStrKeyword_3() { return cStrKeyword_3; }
		
		//'int'
		public Keyword getIntKeyword_4() { return cIntKeyword_4; }
		
		//'flt'
		public Keyword getFltKeyword_5() { return cFltKeyword_5; }
		
		//'lda'
		public Keyword getLdaKeyword_6() { return cLdaKeyword_6; }
		
		//'ltm'
		public Keyword getLtmKeyword_7() { return cLtmKeyword_7; }
		
		//'ldt'
		public Keyword getLdtKeyword_8() { return cLdtKeyword_8; }
		
		//'map'
		public Keyword getMapKeyword_9() { return cMapKeyword_9; }
		
		//'lst'
		public Keyword getLstKeyword_10() { return cLstKeyword_10; }
		
		//'enum'
		public Keyword getEnumKeyword_11() { return cEnumKeyword_11; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBoolLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStrLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFltLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDateLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTimeLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cDateTimeLiteralParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cPathLiteralParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cListLiteralParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cMapLiteralParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEnumLiteralParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cPatternLiteralParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Literals
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Literal:
		//	BoolLiteral
		//	| StrLiteral
		//	| IntLiteral
		//	| FltLiteral
		//	| DateLiteral
		//	| TimeLiteral
		//	| DateTimeLiteral
		//	| PathLiteral
		//	| ListLiteral
		//	| MapLiteral
		//	| EnumLiteral
		//	| PatternLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//BoolLiteral | StrLiteral | IntLiteral | FltLiteral | DateLiteral | TimeLiteral | DateTimeLiteral | PathLiteral |
		//ListLiteral | MapLiteral | EnumLiteral | PatternLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BoolLiteral
		public RuleCall getBoolLiteralParserRuleCall_0() { return cBoolLiteralParserRuleCall_0; }
		
		//StrLiteral
		public RuleCall getStrLiteralParserRuleCall_1() { return cStrLiteralParserRuleCall_1; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_2() { return cIntLiteralParserRuleCall_2; }
		
		//FltLiteral
		public RuleCall getFltLiteralParserRuleCall_3() { return cFltLiteralParserRuleCall_3; }
		
		//DateLiteral
		public RuleCall getDateLiteralParserRuleCall_4() { return cDateLiteralParserRuleCall_4; }
		
		//TimeLiteral
		public RuleCall getTimeLiteralParserRuleCall_5() { return cTimeLiteralParserRuleCall_5; }
		
		//DateTimeLiteral
		public RuleCall getDateTimeLiteralParserRuleCall_6() { return cDateTimeLiteralParserRuleCall_6; }
		
		//PathLiteral
		public RuleCall getPathLiteralParserRuleCall_7() { return cPathLiteralParserRuleCall_7; }
		
		//ListLiteral
		public RuleCall getListLiteralParserRuleCall_8() { return cListLiteralParserRuleCall_8; }
		
		//MapLiteral
		public RuleCall getMapLiteralParserRuleCall_9() { return cMapLiteralParserRuleCall_9; }
		
		//EnumLiteral
		public RuleCall getEnumLiteralParserRuleCall_10() { return cEnumLiteralParserRuleCall_10; }
		
		//PatternLiteral
		public RuleCall getPatternLiteralParserRuleCall_11() { return cPatternLiteralParserRuleCall_11; }
	}
	public class BoolLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BoolLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cFalseKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cValueTrueKeyword_1_1_0 = (Keyword)cValueAssignment_1_1.eContents().get(0);
		
		//BoolLiteral:
		//	{BoolLiteral} ('false' | value?='true');
		@Override public ParserRule getRule() { return rule; }
		
		//{BoolLiteral} ('false' | value?='true')
		public Group getGroup() { return cGroup; }
		
		//{BoolLiteral}
		public Action getBoolLiteralAction_0() { return cBoolLiteralAction_0; }
		
		//'false' | value?='true'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'false'
		public Keyword getFalseKeyword_1_0() { return cFalseKeyword_1_0; }
		
		//value?='true'
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//'true'
		public Keyword getValueTrueKeyword_1_1_0() { return cValueTrueKeyword_1_1_0; }
	}
	public class StrLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.StrLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTEXTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StrLiteral:
		//	value=TEXT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TEXT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//TEXT
		public RuleCall getValueTEXTTerminalRuleCall_0() { return cValueTEXTTerminalRuleCall_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.IntLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNATURALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntLiteral:
		//	value=NATURAL;
		@Override public ParserRule getRule() { return rule; }
		
		//value=NATURAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//NATURAL
		public RuleCall getValueNATURALTerminalRuleCall_0() { return cValueNATURALTerminalRuleCall_0; }
	}
	public class FltLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FltLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//FltLiteral:
		//	value=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=FLOAT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_0() { return cValueFLOATTerminalRuleCall_0; }
	}
	public class DateLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DateLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateLiteral:
		//	value=DATE;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DATE
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DATE
		public RuleCall getValueDATETerminalRuleCall_0() { return cValueDATETerminalRuleCall_0; }
	}
	public class TimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TimeLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTIMETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//TimeLiteral:
		//	value=TIME;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TIME
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//TIME
		public RuleCall getValueTIMETerminalRuleCall_0() { return cValueTIMETerminalRuleCall_0; }
	}
	public class DateTimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DateTimeLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATETIMETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateTimeLiteral:
		//	value=DATETIME;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DATETIME
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DATETIME
		public RuleCall getValueDATETIMETerminalRuleCall_0() { return cValueDATETIMETerminalRuleCall_0; }
	}
	public class PathLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PathLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValuePATHTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//PathLiteral:
		//	value=PATH;
		@Override public ParserRule getRule() { return rule; }
		
		//value=PATH
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//PATH
		public RuleCall getValuePATHTerminalRuleCall_0() { return cValuePATHTerminalRuleCall_0; }
	}
	public class ListLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ListLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValsLiteralParserRuleCall_2_0_0 = (RuleCall)cValsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cValsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValsLiteralParserRuleCall_2_1_1_0 = (RuleCall)cValsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ListLiteral:
		//	{ListLiteral}
		//	'[' (vals+=Literal (',' vals+=Literal)*)? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{ListLiteral} '[' (vals+=Literal (',' vals+=Literal)*)? ']'
		public Group getGroup() { return cGroup; }
		
		//{ListLiteral}
		public Action getListLiteralAction_0() { return cListLiteralAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//(vals+=Literal (',' vals+=Literal)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//vals+=Literal
		public Assignment getValsAssignment_2_0() { return cValsAssignment_2_0; }
		
		//Literal
		public RuleCall getValsLiteralParserRuleCall_2_0_0() { return cValsLiteralParserRuleCall_2_0_0; }
		
		//(',' vals+=Literal)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//vals+=Literal
		public Assignment getValsAssignment_2_1_1() { return cValsAssignment_2_1_1; }
		
		//Literal
		public RuleCall getValsLiteralParserRuleCall_2_1_1_0() { return cValsLiteralParserRuleCall_2_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Action cMapLiteralAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Assignment cEntriesAssignment_0_0_2_0 = (Assignment)cGroup_0_0_2.eContents().get(0);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0 = (RuleCall)cEntriesAssignment_0_0_2_0.eContents().get(0);
		private final Group cGroup_0_0_2_1 = (Group)cGroup_0_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_0_0_2_1_0 = (Keyword)cGroup_0_0_2_1.eContents().get(0);
		private final Assignment cEntriesAssignment_0_0_2_1_1 = (Assignment)cGroup_0_0_2_1.eContents().get(1);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0 = (RuleCall)cEntriesAssignment_0_0_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMapLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cEntriesAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_1_3_0_0 = (RuleCall)cEntriesAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final RuleCall cBREAKParserRuleCall_1_3_1_0 = (RuleCall)cGroup_1_3_1.eContents().get(0);
		private final Assignment cEntriesAssignment_1_3_1_1 = (Assignment)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0 = (RuleCall)cEntriesAssignment_1_3_1_1.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//MapLiteral:
		//	=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{'
		//	BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
		//	END
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{' BEGIN
		//(entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)? END '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}')
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}'
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_0_0_0() { return cMapLiteralAction_0_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0_1() { return cLeftCurlyBracketKeyword_0_0_1; }
		
		//(entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)?
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_0_0_2_0() { return cEntriesAssignment_0_0_2_0; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0() { return cEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0; }
		
		//(',' entries+=MapEntryLiteral)*
		public Group getGroup_0_0_2_1() { return cGroup_0_0_2_1; }
		
		//','
		public Keyword getCommaKeyword_0_0_2_1_0() { return cCommaKeyword_0_0_2_1_0; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_0_0_2_1_1() { return cEntriesAssignment_0_0_2_1_1; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0() { return cEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_0_3() { return cRightCurlyBracketKeyword_0_0_3; }
		
		//{MapLiteral} '{' BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)? END '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_1_0() { return cMapLiteralAction_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1_2() { return cBEGINTerminalRuleCall_1_2; }
		
		//(entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_1_3_0() { return cEntriesAssignment_1_3_0; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_1_3_0_0() { return cEntriesMapEntryLiteralParserRuleCall_1_3_0_0; }
		
		//(BREAK entries+=MapEntryLiteral)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_1_3_1_0() { return cBREAKParserRuleCall_1_3_1_0; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_1_3_1_1() { return cEntriesAssignment_1_3_1_1; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0() { return cEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_1_4() { return cENDTerminalRuleCall_1_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }
	}
	public class MapEntryLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapEntryLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueLiteralParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//MapEntryLiteral:
		//	name=ID ':' value=Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' value=Literal
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//value=Literal
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_2_0() { return cValueLiteralParserRuleCall_2_0; }
	}
	public class EnumLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEnumLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCommercialAtKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRefEnumItemDefCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefEnumItemDefIDTerminalRuleCall_2_0_1 = (RuleCall)cRefEnumItemDefCrossReference_2_0.eContents().get(1);
		
		//EnumLiteral:
		//	{EnumLiteral}
		//	'@' ref=[EnumItemDef];
		@Override public ParserRule getRule() { return rule; }
		
		//{EnumLiteral} '@' ref=[EnumItemDef]
		public Group getGroup() { return cGroup; }
		
		//{EnumLiteral}
		public Action getEnumLiteralAction_0() { return cEnumLiteralAction_0; }
		
		//'@'
		public Keyword getCommercialAtKeyword_1() { return cCommercialAtKeyword_1; }
		
		//ref=[EnumItemDef]
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//[EnumItemDef]
		public CrossReference getRefEnumItemDefCrossReference_2_0() { return cRefEnumItemDefCrossReference_2_0; }
		
		//ID
		public RuleCall getRefEnumItemDefIDTerminalRuleCall_2_0_1() { return cRefEnumItemDefIDTerminalRuleCall_2_0_1; }
	}
	public class PatternLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PatternLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cNativeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cNativeNativeDefParserRuleCall_1_0_0 = (RuleCall)cNativeAssignment_1_0.eContents().get(0);
		private final Assignment cRefAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cRefDefinitionCrossReference_1_1_0 = (CrossReference)cRefAssignment_1_1.eContents().get(0);
		private final RuleCall cRefDefinitionIDTerminalRuleCall_1_1_0_1 = (RuleCall)cRefDefinitionCrossReference_1_1_0.eContents().get(1);
		private final Keyword cCommercialAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTextTEXTTerminalRuleCall_3_0 = (RuleCall)cTextAssignment_3.eContents().get(0);
		
		//PatternLiteral:
		//	{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT;
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT
		public Group getGroup() { return cGroup; }
		
		//{PatternLiteral}
		public Action getPatternLiteralAction_0() { return cPatternLiteralAction_0; }
		
		//native=NativeDef | ref=[Definition]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//native=NativeDef
		public Assignment getNativeAssignment_1_0() { return cNativeAssignment_1_0; }
		
		//NativeDef
		public RuleCall getNativeNativeDefParserRuleCall_1_0_0() { return cNativeNativeDefParserRuleCall_1_0_0; }
		
		//ref=[Definition]
		public Assignment getRefAssignment_1_1() { return cRefAssignment_1_1; }
		
		//[Definition]
		public CrossReference getRefDefinitionCrossReference_1_1_0() { return cRefDefinitionCrossReference_1_1_0; }
		
		//ID
		public RuleCall getRefDefinitionIDTerminalRuleCall_1_1_0_1() { return cRefDefinitionIDTerminalRuleCall_1_1_0_1; }
		
		//'@'
		public Keyword getCommercialAtKeyword_2() { return cCommercialAtKeyword_2; }
		
		//text=TEXT
		public Assignment getTextAssignment_3() { return cTextAssignment_3; }
		
		//TEXT
		public RuleCall getTextTEXTTerminalRuleCall_3_0() { return cTextTEXTTerminalRuleCall_3_0; }
	}
	public class BREAKElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BREAK");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLineFeedKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCarriageReturnKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BREAK:
		//	('\n' | '\r')*;
		@Override public ParserRule getRule() { return rule; }
		
		//('\n' | '\r')*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'\n'
		public Keyword getLineFeedKeyword_0() { return cLineFeedKeyword_0; }
		
		//'\r'
		public Keyword getCarriageReturnKeyword_1() { return cCarriageReturnKeyword_1; }
	}
	
	
	private final ModuleElements pModule;
	private final ImportElements pImport;
	private final ExternalDefElements pExternalDef;
	private final PlugDslElements pPlugDsl;
	private final FunctionElements pFunction;
	private final FuncDeclElements pFuncDecl;
	private final SubPathElements pSubPath;
	private final BlockExpressionElements pBlockExpression;
	private final ExpressionElements pExpression;
	private final IdentifierElements pIdentifier;
	private final VarElements pVar;
	private final ValueExpressionElements pValueExpression;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final EqualityExpressionElements pEqualityExpression;
	private final RelationalExpressionElements pRelationalExpression;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final UnaryOperationElements pUnaryOperation;
	private final BaseExpressionElements pBaseExpression;
	private final PrimaryElements pPrimary;
	private final MemberCallElements pMemberCall;
	private final DefinitionElements pDefinition;
	private final TypeDefElements pTypeDef;
	private final TopDefElements pTopDef;
	private final ElementDefElements pElementDef;
	private final MapDefElements pMapDef;
	private final MapEntryDefElements pMapEntryDef;
	private final ListDefElements pListDef;
	private final EnumDefElements pEnumDef;
	private final EnumItemDefElements pEnumItemDef;
	private final NativeDefElements pNativeDef;
	private final LiteralElements pLiteral;
	private final BoolLiteralElements pBoolLiteral;
	private final StrLiteralElements pStrLiteral;
	private final IntLiteralElements pIntLiteral;
	private final FltLiteralElements pFltLiteral;
	private final DateLiteralElements pDateLiteral;
	private final TimeLiteralElements pTimeLiteral;
	private final DateTimeLiteralElements pDateTimeLiteral;
	private final PathLiteralElements pPathLiteral;
	private final ListLiteralElements pListLiteral;
	private final MapLiteralElements pMapLiteral;
	private final MapEntryLiteralElements pMapEntryLiteral;
	private final EnumLiteralElements pEnumLiteral;
	private final PatternLiteralElements pPatternLiteral;
	private final BREAKElements pBREAK;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tPATH;
	private final TerminalRule tID;
	private final TerminalRule tINT;
	private final TerminalRule tNATURAL;
	private final TerminalRule tFLOAT;
	private final TerminalRule tDATE;
	private final TerminalRule tTIME;
	private final TerminalRule tDATETIME;
	private final TerminalRule tTEXT;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public EldmDslGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModule = new ModuleElements();
		this.pImport = new ImportElements();
		this.pExternalDef = new ExternalDefElements();
		this.pPlugDsl = new PlugDslElements();
		this.pFunction = new FunctionElements();
		this.pFuncDecl = new FuncDeclElements();
		this.pSubPath = new SubPathElements();
		this.pBlockExpression = new BlockExpressionElements();
		this.pExpression = new ExpressionElements();
		this.pIdentifier = new IdentifierElements();
		this.pVar = new VarElements();
		this.pValueExpression = new ValueExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pEqualityExpression = new EqualityExpressionElements();
		this.pRelationalExpression = new RelationalExpressionElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pUnaryOperation = new UnaryOperationElements();
		this.pBaseExpression = new BaseExpressionElements();
		this.pPrimary = new PrimaryElements();
		this.pMemberCall = new MemberCallElements();
		this.pDefinition = new DefinitionElements();
		this.pTypeDef = new TypeDefElements();
		this.pTopDef = new TopDefElements();
		this.pElementDef = new ElementDefElements();
		this.pMapDef = new MapDefElements();
		this.pMapEntryDef = new MapEntryDefElements();
		this.pListDef = new ListDefElements();
		this.pEnumDef = new EnumDefElements();
		this.pEnumItemDef = new EnumItemDefElements();
		this.pNativeDef = new NativeDefElements();
		this.pLiteral = new LiteralElements();
		this.pBoolLiteral = new BoolLiteralElements();
		this.pStrLiteral = new StrLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pFltLiteral = new FltLiteralElements();
		this.pDateLiteral = new DateLiteralElements();
		this.pTimeLiteral = new TimeLiteralElements();
		this.pDateTimeLiteral = new DateTimeLiteralElements();
		this.pPathLiteral = new PathLiteralElements();
		this.pListLiteral = new ListLiteralElements();
		this.pMapLiteral = new MapLiteralElements();
		this.pMapEntryLiteral = new MapEntryLiteralElements();
		this.pEnumLiteral = new EnumLiteralElements();
		this.pPatternLiteral = new PatternLiteralElements();
		this.pBREAK = new BREAKElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.END");
		this.tPATH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PATH");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ID");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.INT");
		this.tNATURAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.NATURAL");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FLOAT");
		this.tDATE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DATE");
		this.tTIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TIME");
		this.tDATETIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DATETIME");
		this.tTEXT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TEXT");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.eldm.EldmDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Module Header
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Module:
	//	'module' name=PathLiteral
	//	imports+=Import*
	//	plugs+=PlugDsl* ('definitions:'
	//	BEGIN
	//	defs+=Definition*
	//	vars+=Var*
	//	END)?
	//	funcs+=Function*
	//	paths+=SubPath*;
	public ModuleElements getModuleAccess() {
		return pModule;
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}
	
	//Import:
	//	'import' (path=PathLiteral | defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral BREAK;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ExternalDef:
	//	ref=ID ('as' name=ID)? | => name=ID //TODO: check-if is a valid reference to a Definition ID
	//;
	public ExternalDefElements getExternalDefAccess() {
		return pExternalDef;
	}
	
	public ParserRule getExternalDefRule() {
		return getExternalDefAccess().getRule();
	}
	
	//PlugDsl:
	//	'plug-dsl' name=ID 'from' ref=PathLiteral BREAK;
	public PlugDslElements getPlugDslAccess() {
		return pPlugDsl;
	}
	
	public ParserRule getPlugDslRule() {
		return getPlugDslAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Operations
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Function:
	//	decl=FuncDecl
	//	body=BlockExpression;
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}
	
	//FuncDecl:
	//	type='catch' param=ElementDef? ':'
	//	| type='def' srv?='service'? (get?='get' | 'set') path=PathLiteral? param=ElementDef? ('->' result=ElementDef)? ':';
	public FuncDeclElements getFuncDeclAccess() {
		return pFuncDecl;
	}
	
	public ParserRule getFuncDeclRule() {
		return getFuncDeclAccess().getRule();
	}
	
	//SubPath:
	//	'def' path=PathLiteral
	//	BEGIN
	//	funcs+=Function+
	//	END;
	public SubPathElements getSubPathAccess() {
		return pSubPath;
	}
	
	public ParserRule getSubPathRule() {
		return getSubPathAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Expressions
	//// ------------------------------------------------------------------------------------------------------------------------------
	//BlockExpression:
	//	{BlockExpression} BEGIN
	//	expressions+=Expression*
	//	END;
	public BlockExpressionElements getBlockExpressionAccess() {
		return pBlockExpression;
	}
	
	public ParserRule getBlockExpressionRule() {
		return getBlockExpressionAccess().getRule();
	}
	
	//Expression:
	//	Identifier;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Identifier:
	//	Var // | Param
	//;
	public IdentifierElements getIdentifierAccess() {
		return pIdentifier;
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	//Var:
	//	(let?='let' | 'var') name=ID (':' type=ElementDef)? '=' result=ValueExpression;
	public VarElements getVarAccess() {
		return pVar;
	}
	
	public ParserRule getVarRule() {
		return getVarAccess().getRule();
	}
	
	//// the result expression must be equivalent to an immutable Literal
	//ValueExpression:
	//	OrExpression;
	public ValueExpressionElements getValueExpressionAccess() {
		return pValueExpression;
	}
	
	public ParserRule getValueExpressionRule() {
		return getValueExpressionAccess().getRule();
	}
	
	//OrExpression ValueExpression:
	//	AndExpression (=> ({ValueExpression.left=current} feature='or') right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//AndExpression ValueExpression:
	//	EqualityExpression (=> ({ValueExpression.left=current} feature='and') right=EqualityExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//EqualityExpression ValueExpression:
	//	RelationalExpression (=> ({ValueExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return pEqualityExpression;
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}
	
	//RelationalExpression ValueExpression:
	//	AdditiveExpression (=> ({IsExpression.left=current} feature='is') type=ElementDef
	//	| => ({ValueExpression.left=current} feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return pRelationalExpression;
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}
	
	//AdditiveExpression ValueExpression:
	//	MultiplicativeExpression (=> ({ValueExpression.left=current} feature=('+' | '-' | 'set' | 'del'))
	//	right=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//MultiplicativeExpression ValueExpression:
	//	UnaryOperation (=> ({ValueExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//// UnaryOperation -> (feature operand)
	//UnaryOperation ValueExpression:
	//	{UnaryOperation} feature='!' operand=UnaryOperation | BaseExpression;
	public UnaryOperationElements getUnaryOperationAccess() {
		return pUnaryOperation;
	}
	
	public ParserRule getUnaryOperationRule() {
		return getUnaryOperationAccess().getRule();
	}
	
	//BaseExpression ValueExpression:
	//	Primary | '(' ValueExpression ')';
	public BaseExpressionElements getBaseExpressionAccess() {
		return pBaseExpression;
	}
	
	public ParserRule getBaseExpressionRule() {
		return getBaseExpressionAccess().getRule();
	}
	
	//Primary:
	//	('«' type=ElementDef '»')? (value=Literal | ref=ID) calls+=MemberCall*;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//MemberCall:
	//	('.' | nullSafe?='?.') member=ID;
	public MemberCallElements getMemberCallAccess() {
		return pMemberCall;
	}
	
	public ParserRule getMemberCallRule() {
		return getMemberCallAccess().getRule();
	}
	
	///*
	//OperationCall:
	//  async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression
	//;
	//
	//PostfixOperation returns ResultExpression:
	//  BaseExpression =>({UnaryOperation.operand=current} feature=('++'|'--'))?
	//;
	//* */ // ------------------------------------------------------------------------------------------------------------------------------
	//// Type Definitions
	//// ------------------------------------------------------------------------------------------------------------------------------
	///*LambdaDef:
	//  '#(' param=ElementDef ('->' result=ElementDef)? ')'
	//;*/ Definition:
	//	TypeDef | ExternalDef;
	public DefinitionElements getDefinitionAccess() {
		return pDefinition;
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}
	
	//TypeDef:
	//	'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=TopDef);
	public TypeDefElements getTypeDefAccess() {
		return pTypeDef;
	}
	
	public ParserRule getTypeDefRule() {
		return getTypeDefAccess().getRule();
	}
	
	//TopDef:
	//	ElementDef | EnumDef;
	public TopDefElements getTopDefAccess() {
		return pTopDef;
	}
	
	public ParserRule getTopDefRule() {
		return getTopDefAccess().getRule();
	}
	
	//ElementDef:
	//	native=NativeDef
	//	| ref=[Definition] | ListDef
	//	| MapDef;
	public ElementDefElements getElementDefAccess() {
		return pElementDef;
	}
	
	public ParserRule getElementDefRule() {
		return getElementDefAccess().getRule();
	}
	
	//MapDef:
	//	=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? (',' ext?='*')? '}') | {MapDef} '{'
	//	BEGIN (defs+=MapEntryDef (','? BREAK defs+=MapEntryDef)*)?
	//	ext?='*'?
	//	END
	//	'}';
	public MapDefElements getMapDefAccess() {
		return pMapDef;
	}
	
	public ParserRule getMapDefRule() {
		return getMapDefAccess().getRule();
	}
	
	//MapEntryDef:
	//	name=ID (opt?='?'? ':' type=ElementDef | opt?='=' value=Literal)?;
	public MapEntryDefElements getMapEntryDefAccess() {
		return pMapEntryDef;
	}
	
	public ParserRule getMapEntryDefRule() {
		return getMapEntryDefAccess().getRule();
	}
	
	//ListDef:
	//	{ListDef}
	//	'..' type=ElementDef;
	public ListDefElements getListDefAccess() {
		return pListDef;
	}
	
	public ParserRule getListDefRule() {
		return getListDefAccess().getRule();
	}
	
	//EnumDef:
	//	'enum' type=MapDef? ':'
	//	BEGIN
	//	defs+=EnumItemDef+
	//	END;
	public EnumDefElements getEnumDefAccess() {
		return pEnumDef;
	}
	
	public ParserRule getEnumDefRule() {
		return getEnumDefAccess().getRule();
	}
	
	//EnumItemDef:
	//	name=ID value=MapLiteral?;
	public EnumItemDefElements getEnumItemDefAccess() {
		return pEnumItemDef;
	}
	
	public ParserRule getEnumItemDefRule() {
		return getEnumItemDefAccess().getRule();
	}
	
	//NativeDef:
	//	'any' | 'path'
	//	| 'bool' | 'str' | 'int' | 'flt'
	//	| 'lda' | 'ltm' | 'ldt'
	//	| 'map' | 'lst' | 'enum';
	public NativeDefElements getNativeDefAccess() {
		return pNativeDef;
	}
	
	public ParserRule getNativeDefRule() {
		return getNativeDefAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Literals
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Literal:
	//	BoolLiteral
	//	| StrLiteral
	//	| IntLiteral
	//	| FltLiteral
	//	| DateLiteral
	//	| TimeLiteral
	//	| DateTimeLiteral
	//	| PathLiteral
	//	| ListLiteral
	//	| MapLiteral
	//	| EnumLiteral
	//	| PatternLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BoolLiteral:
	//	{BoolLiteral} ('false' | value?='true');
	public BoolLiteralElements getBoolLiteralAccess() {
		return pBoolLiteral;
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}
	
	//StrLiteral:
	//	value=TEXT;
	public StrLiteralElements getStrLiteralAccess() {
		return pStrLiteral;
	}
	
	public ParserRule getStrLiteralRule() {
		return getStrLiteralAccess().getRule();
	}
	
	//IntLiteral:
	//	value=NATURAL;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	//FltLiteral:
	//	value=FLOAT;
	public FltLiteralElements getFltLiteralAccess() {
		return pFltLiteral;
	}
	
	public ParserRule getFltLiteralRule() {
		return getFltLiteralAccess().getRule();
	}
	
	//DateLiteral:
	//	value=DATE;
	public DateLiteralElements getDateLiteralAccess() {
		return pDateLiteral;
	}
	
	public ParserRule getDateLiteralRule() {
		return getDateLiteralAccess().getRule();
	}
	
	//TimeLiteral:
	//	value=TIME;
	public TimeLiteralElements getTimeLiteralAccess() {
		return pTimeLiteral;
	}
	
	public ParserRule getTimeLiteralRule() {
		return getTimeLiteralAccess().getRule();
	}
	
	//DateTimeLiteral:
	//	value=DATETIME;
	public DateTimeLiteralElements getDateTimeLiteralAccess() {
		return pDateTimeLiteral;
	}
	
	public ParserRule getDateTimeLiteralRule() {
		return getDateTimeLiteralAccess().getRule();
	}
	
	//PathLiteral:
	//	value=PATH;
	public PathLiteralElements getPathLiteralAccess() {
		return pPathLiteral;
	}
	
	public ParserRule getPathLiteralRule() {
		return getPathLiteralAccess().getRule();
	}
	
	//ListLiteral:
	//	{ListLiteral}
	//	'[' (vals+=Literal (',' vals+=Literal)*)? ']';
	public ListLiteralElements getListLiteralAccess() {
		return pListLiteral;
	}
	
	public ParserRule getListLiteralRule() {
		return getListLiteralAccess().getRule();
	}
	
	//MapLiteral:
	//	=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{'
	//	BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
	//	END
	//	'}';
	public MapLiteralElements getMapLiteralAccess() {
		return pMapLiteral;
	}
	
	public ParserRule getMapLiteralRule() {
		return getMapLiteralAccess().getRule();
	}
	
	//MapEntryLiteral:
	//	name=ID ':' value=Literal;
	public MapEntryLiteralElements getMapEntryLiteralAccess() {
		return pMapEntryLiteral;
	}
	
	public ParserRule getMapEntryLiteralRule() {
		return getMapEntryLiteralAccess().getRule();
	}
	
	//EnumLiteral:
	//	{EnumLiteral}
	//	'@' ref=[EnumItemDef];
	public EnumLiteralElements getEnumLiteralAccess() {
		return pEnumLiteral;
	}
	
	public ParserRule getEnumLiteralRule() {
		return getEnumLiteralAccess().getRule();
	}
	
	//PatternLiteral:
	//	{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT;
	public PatternLiteralElements getPatternLiteralAccess() {
		return pPatternLiteral;
	}
	
	public ParserRule getPatternLiteralRule() {
		return getPatternLiteralAccess().getRule();
	}
	
	//BREAK:
	//	('\n' | '\r')*;
	public BREAKElements getBREAKAccess() {
		return pBREAK;
	}
	
	public ParserRule getBREAKRule() {
		return getBREAKAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal PATH:
	//	'/' ('a'..'z' | '-' | '0'..'9')+*;
	public TerminalRule getPATHRule() {
		return tPATH;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '-' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal INT:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal NATURAL:
	//	'-'? INT;
	public TerminalRule getNATURALRule() {
		return tNATURAL;
	}
	
	//terminal FLOAT:
	//	NATURAL ('.' INT)?;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal DATE:
	//	INT '-' ('0' '1'..'9' | '1' '0'..'2') '-' ('0' '1'..'9' | '1'..'2' '0'..'9' | '3' '0'..'1');
	public TerminalRule getDATERule() {
		return tDATE;
	}
	
	//terminal TIME:
	//	('0'..'1' '0'..'9' | '2' '0'..'3') ':' ('0'..'5' '0'..'9') ':' ('0'..'5' '0'..'9');
	public TerminalRule getTIMERule() {
		return tTIME;
	}
	
	//terminal DATETIME:
	//	DATE 'T' TIME;
	public TerminalRule getDATETIMERule() {
		return tDATETIME;
	}
	
	//terminal TEXT:
	//	"'" !("'" | '\r' | '\n')* "'" | '"""'->'"""';
	public TerminalRule getTEXTRule() {
		return tTEXT;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
