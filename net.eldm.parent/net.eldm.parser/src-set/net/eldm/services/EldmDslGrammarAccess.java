/*
 * generated by Xtext 2.15.0
 */
package net.eldm.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class EldmDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePathLiteralParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cPlugsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPlugsPlugDslParserRuleCall_3_0 = (RuleCall)cPlugsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cDefinitionsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cDefsAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cDefsDefinitionParserRuleCall_4_2_0 = (RuleCall)cDefsAssignment_4_2.eContents().get(0);
		private final Assignment cValsAssignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cValsLetValueParserRuleCall_4_3_0 = (RuleCall)cValsAssignment_4_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4_4 = (RuleCall)cGroup_4.eContents().get(4);
		private final Assignment cOpersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cOpersOperationParserRuleCall_5_0 = (RuleCall)cOpersAssignment_5.eContents().get(0);
		private final Assignment cPathsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPathsSubPathParserRuleCall_6_0 = (RuleCall)cPathsAssignment_6.eContents().get(0);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Module Header
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Module:
		//	'module' name=PathLiteral
		//	imports+=Import*
		//	plugs+=PlugDsl* ('definitions:'
		//	BEGIN
		//	defs+=Definition*
		//	vals+=LetValue*
		//	END)?
		//	opers+=Operation*
		//	paths+=SubPath*;
		@Override public ParserRule getRule() { return rule; }
		
		//'module' name=PathLiteral imports+=Import* plugs+=PlugDsl* ('definitions:' BEGIN defs+=Definition* vals+=LetValue* END)?
		//opers+=Operation* paths+=SubPath*
		public Group getGroup() { return cGroup; }
		
		//'module'
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_1_0() { return cNamePathLiteralParserRuleCall_1_0; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }
		
		//plugs+=PlugDsl*
		public Assignment getPlugsAssignment_3() { return cPlugsAssignment_3; }
		
		//PlugDsl
		public RuleCall getPlugsPlugDslParserRuleCall_3_0() { return cPlugsPlugDslParserRuleCall_3_0; }
		
		//('definitions:' BEGIN defs+=Definition* vals+=LetValue* END)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'definitions:'
		public Keyword getDefinitionsKeyword_4_0() { return cDefinitionsKeyword_4_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_4_1() { return cBEGINTerminalRuleCall_4_1; }
		
		//defs+=Definition*
		public Assignment getDefsAssignment_4_2() { return cDefsAssignment_4_2; }
		
		//Definition
		public RuleCall getDefsDefinitionParserRuleCall_4_2_0() { return cDefsDefinitionParserRuleCall_4_2_0; }
		
		//vals+=LetValue*
		public Assignment getValsAssignment_4_3() { return cValsAssignment_4_3; }
		
		//LetValue
		public RuleCall getValsLetValueParserRuleCall_4_3_0() { return cValsLetValueParserRuleCall_4_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4_4() { return cENDTerminalRuleCall_4_4; }
		
		//opers+=Operation*
		public Assignment getOpersAssignment_5() { return cOpersAssignment_5; }
		
		//Operation
		public RuleCall getOpersOperationParserRuleCall_5_0() { return cOpersOperationParserRuleCall_5_0; }
		
		//paths+=SubPath*
		public Assignment getPathsAssignment_6() { return cPathsAssignment_6; }
		
		//SubPath
		public RuleCall getPathsSubPathParserRuleCall_6_0() { return cPathsSubPathParserRuleCall_6_0; }
	}
	public class PlugDslElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PlugDsl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPlugDslKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cAdaptorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAdaptorPatternLiteralParserRuleCall_2_0 = (RuleCall)cAdaptorAssignment_2.eContents().get(0);
		
		//PlugDsl:
		//	'plug-dsl' name=ID adaptor=PatternLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//'plug-dsl' name=ID adaptor=PatternLiteral
		public Group getGroup() { return cGroup; }
		
		//'plug-dsl'
		public Keyword getPlugDslKeyword_0() { return cPlugDslKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//adaptor=PatternLiteral
		public Assignment getAdaptorAssignment_2() { return cAdaptorAssignment_2; }
		
		//PatternLiteral
		public RuleCall getAdaptorPatternLiteralParserRuleCall_2_0() { return cAdaptorPatternLiteralParserRuleCall_2_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Import");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImportOperationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cImportDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Import:
		//	ImportOperation | ImportDefinition;
		@Override public ParserRule getRule() { return rule; }
		
		//ImportOperation | ImportDefinition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ImportOperation
		public RuleCall getImportOperationParserRuleCall_0() { return cImportOperationParserRuleCall_0; }
		
		//ImportDefinition
		public RuleCall getImportDefinitionParserRuleCall_1() { return cImportDefinitionParserRuleCall_1; }
	}
	public class ImportOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ImportOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePathLiteralParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefPathLiteralParserRuleCall_2_0 = (RuleCall)cRefAssignment_2.eContents().get(0);
		
		//ImportOperation Import:
		//	name=PathLiteral 'from' ref=PathLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PathLiteral 'from' ref=PathLiteral
		public Group getGroup() { return cGroup; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_0_0() { return cNamePathLiteralParserRuleCall_0_0; }
		
		//'from'
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }
		
		//ref=PathLiteral
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//PathLiteral
		public RuleCall getRefPathLiteralParserRuleCall_2_0() { return cRefPathLiteralParserRuleCall_2_0; }
	}
	public class ImportDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ImportDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cDefsAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cDefsExternalDefParserRuleCall_0_0_0 = (RuleCall)cDefsAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cDefsAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cDefsExternalDefParserRuleCall_0_1_1_0 = (RuleCall)cDefsAssignment_0_1_1.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefPathLiteralParserRuleCall_2_0 = (RuleCall)cRefAssignment_2.eContents().get(0);
		
		//ImportDefinition Import:
		//	(defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//(defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral
		public Group getGroup() { return cGroup; }
		
		//defs+=ExternalDef (',' defs+=ExternalDef)*
		public Group getGroup_0() { return cGroup_0; }
		
		//defs+=ExternalDef
		public Assignment getDefsAssignment_0_0() { return cDefsAssignment_0_0; }
		
		//ExternalDef
		public RuleCall getDefsExternalDefParserRuleCall_0_0_0() { return cDefsExternalDefParserRuleCall_0_0_0; }
		
		//(',' defs+=ExternalDef)*
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//','
		public Keyword getCommaKeyword_0_1_0() { return cCommaKeyword_0_1_0; }
		
		//defs+=ExternalDef
		public Assignment getDefsAssignment_0_1_1() { return cDefsAssignment_0_1_1; }
		
		//ExternalDef
		public RuleCall getDefsExternalDefParserRuleCall_0_1_1_0() { return cDefsExternalDefParserRuleCall_0_1_1_0; }
		
		//'from'
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }
		
		//ref=PathLiteral
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//PathLiteral
		public RuleCall getRefPathLiteralParserRuleCall_2_0() { return cRefPathLiteralParserRuleCall_2_0; }
	}
	public class ExternalDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ExternalDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cRefAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cRefIDTerminalRuleCall_0_0_0 = (RuleCall)cRefAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cAsKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cNameAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0_1_1_0 = (RuleCall)cNameAssignment_0_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ExternalDef:
		//	ref=ID ('as' name=ID)? | => name=ID //TODO: check-if is a valid reference to a Definition ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref=ID ('as' name=ID)? | => name=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ref=ID ('as' name=ID)?
		public Group getGroup_0() { return cGroup_0; }
		
		//ref=ID
		public Assignment getRefAssignment_0_0() { return cRefAssignment_0_0; }
		
		//ID
		public RuleCall getRefIDTerminalRuleCall_0_0_0() { return cRefIDTerminalRuleCall_0_0_0; }
		
		//('as' name=ID)?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'as'
		public Keyword getAsKeyword_0_1_0() { return cAsKeyword_0_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_0_1_1() { return cNameAssignment_0_1_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_1_0() { return cNameIDTerminalRuleCall_0_1_1_0; }
		
		//=> name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class OperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Operation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsPrivateAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsPrivatePrivateKeyword_0_0 = (Keyword)cIsPrivateAssignment_0.eContents().get(0);
		private final Keyword cDefKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cIsGetAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final Keyword cIsGetGetKeyword_2_0_0 = (Keyword)cIsGetAssignment_2_0.eContents().get(0);
		private final Keyword cSetKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNamePathLiteralParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cParamAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cParamParamDefParserRuleCall_4_0 = (RuleCall)cParamAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cResultAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cResultElementDefParserRuleCall_5_1_0 = (RuleCall)cResultAssignment_5_1.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBodyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBodyBlockExpressionParserRuleCall_7_0 = (RuleCall)cBodyAssignment_7.eContents().get(0);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Operations
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Operation:
		//	isPrivate?='private'? 'def' (isGet?='get' | 'set') name=PathLiteral? param=ParamDef? ('->' result=ElementDef)? ':'
		//	body=BlockExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//isPrivate?='private'? 'def' (isGet?='get' | 'set') name=PathLiteral? param=ParamDef? ('->' result=ElementDef)? ':'
		//body=BlockExpression
		public Group getGroup() { return cGroup; }
		
		//isPrivate?='private'?
		public Assignment getIsPrivateAssignment_0() { return cIsPrivateAssignment_0; }
		
		//'private'
		public Keyword getIsPrivatePrivateKeyword_0_0() { return cIsPrivatePrivateKeyword_0_0; }
		
		//'def'
		public Keyword getDefKeyword_1() { return cDefKeyword_1; }
		
		//isGet?='get' | 'set'
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//isGet?='get'
		public Assignment getIsGetAssignment_2_0() { return cIsGetAssignment_2_0; }
		
		//'get'
		public Keyword getIsGetGetKeyword_2_0_0() { return cIsGetGetKeyword_2_0_0; }
		
		//'set'
		public Keyword getSetKeyword_2_1() { return cSetKeyword_2_1; }
		
		//name=PathLiteral?
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_3_0() { return cNamePathLiteralParserRuleCall_3_0; }
		
		//param=ParamDef?
		public Assignment getParamAssignment_4() { return cParamAssignment_4; }
		
		//ParamDef
		public RuleCall getParamParamDefParserRuleCall_4_0() { return cParamParamDefParserRuleCall_4_0; }
		
		//('->' result=ElementDef)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_5_0() { return cHyphenMinusGreaterThanSignKeyword_5_0; }
		
		//result=ElementDef
		public Assignment getResultAssignment_5_1() { return cResultAssignment_5_1; }
		
		//ElementDef
		public RuleCall getResultElementDefParserRuleCall_5_1_0() { return cResultElementDefParserRuleCall_5_1_0; }
		
		//':'
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//body=BlockExpression
		public Assignment getBodyAssignment_7() { return cBodyAssignment_7; }
		
		//BlockExpression
		public RuleCall getBodyBlockExpressionParserRuleCall_7_0() { return cBodyBlockExpressionParserRuleCall_7_0; }
	}
	public class ParamDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ParamDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cDefAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cDefMapDefParserRuleCall_0_0 = (RuleCall)cDefAssignment_0.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cRefMapDefCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefMapDefIDTerminalRuleCall_1_0_1 = (RuleCall)cRefMapDefCrossReference_1_0.eContents().get(1);
		
		//ParamDef:
		//	def=MapDef | ref=[MapDef];
		@Override public ParserRule getRule() { return rule; }
		
		//def=MapDef | ref=[MapDef]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//def=MapDef
		public Assignment getDefAssignment_0() { return cDefAssignment_0; }
		
		//MapDef
		public RuleCall getDefMapDefParserRuleCall_0_0() { return cDefMapDefParserRuleCall_0_0; }
		
		//ref=[MapDef]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }
		
		//[MapDef]
		public CrossReference getRefMapDefCrossReference_1_0() { return cRefMapDefCrossReference_1_0; }
		
		//ID
		public RuleCall getRefMapDefIDTerminalRuleCall_1_0_1() { return cRefMapDefIDTerminalRuleCall_1_0_1; }
	}
	public class SubPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.SubPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePathLiteralParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cOpersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOpersOperationParserRuleCall_3_0 = (RuleCall)cOpersAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//SubPath:
		//	'def' name=PathLiteral
		//	BEGIN
		//	opers+=Operation+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'def' name=PathLiteral BEGIN opers+=Operation+ END
		public Group getGroup() { return cGroup; }
		
		//'def'
		public Keyword getDefKeyword_0() { return cDefKeyword_0; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_1_0() { return cNamePathLiteralParserRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//opers+=Operation+
		public Assignment getOpersAssignment_3() { return cOpersAssignment_3; }
		
		//Operation
		public RuleCall getOpersOperationParserRuleCall_3_0() { return cOpersOperationParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class BlockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BlockExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_0 = (RuleCall)cExpressionsAssignment_2.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Expressions
		//// ------------------------------------------------------------------------------------------------------------------------------
		//BlockExpression:
		//	{BlockExpression} BEGIN
		//	expressions+=Expression*
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//{BlockExpression} BEGIN expressions+=Expression* END
		public Group getGroup() { return cGroup; }
		
		//{BlockExpression}
		public Action getBlockExpressionAction_0() { return cBlockExpressionAction_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1() { return cBEGINTerminalRuleCall_1; }
		
		//expressions+=Expression*
		public Assignment getExpressionsAssignment_2() { return cExpressionsAssignment_2; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_0() { return cExpressionsExpressionParserRuleCall_2_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_3() { return cENDTerminalRuleCall_3; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Expression");
		private final RuleCall cLetValueParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	LetValue //TODO: add more expressions?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//LetValue
		public RuleCall getLetValueParserRuleCall() { return cLetValueParserRuleCall; }
	}
	public class LetValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.LetValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIsTypeExplicitAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cIsTypeExplicitColonKeyword_2_0_0 = (Keyword)cIsTypeExplicitAssignment_2_0.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cResultAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cResultResultExpressionParserRuleCall_4_0 = (RuleCall)cResultAssignment_4.eContents().get(0);
		
		//LetValue:
		//	'let' name=ID (isTypeExplicit?=':' type=ElementDef)? '=' result=ResultExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'let' name=ID (isTypeExplicit?=':' type=ElementDef)? '=' result=ResultExpression
		public Group getGroup() { return cGroup; }
		
		//'let'
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(isTypeExplicit?=':' type=ElementDef)?
		public Group getGroup_2() { return cGroup_2; }
		
		//isTypeExplicit?=':'
		public Assignment getIsTypeExplicitAssignment_2_0() { return cIsTypeExplicitAssignment_2_0; }
		
		//':'
		public Keyword getIsTypeExplicitColonKeyword_2_0_0() { return cIsTypeExplicitColonKeyword_2_0_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_1_0() { return cTypeElementDefParserRuleCall_2_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//result=ResultExpression
		public Assignment getResultAssignment_4() { return cResultAssignment_4; }
		
		//ResultExpression
		public RuleCall getResultResultExpressionParserRuleCall_4_0() { return cResultResultExpressionParserRuleCall_4_0; }
	}
	public class ResultExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ResultExpression");
		private final RuleCall cOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// the result expression must be equivalent to a Literal
		//// ResultExpression -> (left feature right)
		//ResultExpression:
		//	OrExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall() { return cOrExpressionParserRuleCall; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cResultExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cFeatureOrKeyword_1_0_0_1_0 = (Keyword)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//OrExpression ResultExpression:
		//	AndExpression (=> ({ResultExpression.left=current} feature='or') right=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression (=> ({ResultExpression.left=current} feature='or') right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//(=> ({ResultExpression.left=current} feature='or') right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ResultExpression.left=current} feature='or')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ResultExpression.left=current} feature='or'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ResultExpression.left=current}
		public Action getResultExpressionLeftAction_1_0_0_0() { return cResultExpressionLeftAction_1_0_0_0; }
		
		//feature='or'
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//'or'
		public Keyword getFeatureOrKeyword_1_0_0_1_0() { return cFeatureOrKeyword_1_0_0_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_1_0() { return cRightAndExpressionParserRuleCall_1_1_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cResultExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cFeatureAndKeyword_1_0_0_1_0 = (Keyword)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEqualityExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AndExpression ResultExpression:
		//	EqualityExpression (=> ({ResultExpression.left=current} feature='and') right=EqualityExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//EqualityExpression (=> ({ResultExpression.left=current} feature='and') right=EqualityExpression)*
		public Group getGroup() { return cGroup; }
		
		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }
		
		//(=> ({ResultExpression.left=current} feature='and') right=EqualityExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ResultExpression.left=current} feature='and')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ResultExpression.left=current} feature='and'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ResultExpression.left=current}
		public Action getResultExpressionLeftAction_1_0_0_0() { return cResultExpressionLeftAction_1_0_0_0; }
		
		//feature='and'
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//'and'
		public Keyword getFeatureAndKeyword_1_0_0_1_0() { return cFeatureAndKeyword_1_0_0_1_0; }
		
		//right=EqualityExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//EqualityExpression
		public RuleCall getRightEqualityExpressionParserRuleCall_1_1_0() { return cRightEqualityExpressionParserRuleCall_1_1_0; }
	}
	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cResultExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cFeatureEqualsSignEqualsSignKeyword_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureExclamationMarkEqualsSignKeyword_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightRelationalExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//EqualityExpression ResultExpression:
		//	RelationalExpression (=> ({ResultExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//RelationalExpression (=> ({ResultExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }
		
		//(=> ({ResultExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ResultExpression.left=current} feature=('==' | '!='))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ResultExpression.left=current} feature=('==' | '!=')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ResultExpression.left=current}
		public Action getResultExpressionLeftAction_1_0_0_0() { return cResultExpressionLeftAction_1_0_0_0; }
		
		//feature=('==' | '!=')
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//('==' | '!=')
		public Alternatives getFeatureAlternatives_1_0_0_1_0() { return cFeatureAlternatives_1_0_0_1_0; }
		
		//'=='
		public Keyword getFeatureEqualsSignEqualsSignKeyword_1_0_0_1_0_0() { return cFeatureEqualsSignEqualsSignKeyword_1_0_0_1_0_0; }
		
		//'!='
		public Keyword getFeatureExclamationMarkEqualsSignKeyword_1_0_0_1_0_1() { return cFeatureExclamationMarkEqualsSignKeyword_1_0_0_1_0_1; }
		
		//right=RelationalExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//RelationalExpression
		public RuleCall getRightRelationalExpressionParserRuleCall_1_1_0() { return cRightRelationalExpressionParserRuleCall_1_1_0; }
	}
	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cGroup_1_0_0.eContents().get(0);
		private final Action cIsExpressionExpressionAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cIsKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_1_0_1_0 = (RuleCall)cTypeAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_0_0 = (Group)cGroup_1_1_0.eContents().get(0);
		private final Action cResultExpressionLeftAction_1_1_0_0_0 = (Action)cGroup_1_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_1_0_0_1 = (Assignment)cGroup_1_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_1_0_0_1.eContents().get(0);
		private final Keyword cFeatureGreaterThanSignEqualsSignKeyword_1_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureLessThanSignEqualsSignKeyword_1_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(1);
		private final Keyword cFeatureGreaterThanSignKeyword_1_1_0_0_1_0_2 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(2);
		private final Keyword cFeatureLessThanSignKeyword_1_1_0_0_1_0_3 = (Keyword)cFeatureAlternatives_1_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_1_1_0 = (RuleCall)cRightAssignment_1_1_1.eContents().get(0);
		
		//RelationalExpression ResultExpression:
		//	AdditiveExpression (=> ({IsExpression.expression=current} 'is') type=ElementDef
		//	| => ({ResultExpression.left=current} feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AdditiveExpression (=> ({IsExpression.expression=current} 'is') type=ElementDef | => ({ResultExpression.left=current}
		//feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*
		public Group getGroup() { return cGroup; }
		
		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }
		
		//(=> ({IsExpression.expression=current} 'is') type=ElementDef | => ({ResultExpression.left=current} feature=('>=' | '<='
		//| '>' | '<')) right=AdditiveExpression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//=> ({IsExpression.expression=current} 'is') type=ElementDef
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//=> ({IsExpression.expression=current} 'is')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{IsExpression.expression=current} 'is'
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }
		
		//{IsExpression.expression=current}
		public Action getIsExpressionExpressionAction_1_0_0_0_0() { return cIsExpressionExpressionAction_1_0_0_0_0; }
		
		//'is'
		public Keyword getIsKeyword_1_0_0_0_1() { return cIsKeyword_1_0_0_0_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_1_0_1() { return cTypeAssignment_1_0_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_1_0_1_0() { return cTypeElementDefParserRuleCall_1_0_1_0; }
		
		//=> ({ResultExpression.left=current} feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//=> ({ResultExpression.left=current} feature=('>=' | '<=' | '>' | '<'))
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }
		
		//{ResultExpression.left=current} feature=('>=' | '<=' | '>' | '<')
		public Group getGroup_1_1_0_0() { return cGroup_1_1_0_0; }
		
		//{ResultExpression.left=current}
		public Action getResultExpressionLeftAction_1_1_0_0_0() { return cResultExpressionLeftAction_1_1_0_0_0; }
		
		//feature=('>=' | '<=' | '>' | '<')
		public Assignment getFeatureAssignment_1_1_0_0_1() { return cFeatureAssignment_1_1_0_0_1; }
		
		//('>=' | '<=' | '>' | '<')
		public Alternatives getFeatureAlternatives_1_1_0_0_1_0() { return cFeatureAlternatives_1_1_0_0_1_0; }
		
		//'>='
		public Keyword getFeatureGreaterThanSignEqualsSignKeyword_1_1_0_0_1_0_0() { return cFeatureGreaterThanSignEqualsSignKeyword_1_1_0_0_1_0_0; }
		
		//'<='
		public Keyword getFeatureLessThanSignEqualsSignKeyword_1_1_0_0_1_0_1() { return cFeatureLessThanSignEqualsSignKeyword_1_1_0_0_1_0_1; }
		
		//'>'
		public Keyword getFeatureGreaterThanSignKeyword_1_1_0_0_1_0_2() { return cFeatureGreaterThanSignKeyword_1_1_0_0_1_0_2; }
		
		//'<'
		public Keyword getFeatureLessThanSignKeyword_1_1_0_0_1_0_3() { return cFeatureLessThanSignKeyword_1_1_0_0_1_0_3; }
		
		//right=AdditiveExpression
		public Assignment getRightAssignment_1_1_1() { return cRightAssignment_1_1_1; }
		
		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_1_1_0() { return cRightAdditiveExpressionParserRuleCall_1_1_1_0; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cResultExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cFeaturePlusSignKeyword_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureHyphenMinusKeyword_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AdditiveExpression ResultExpression:
		//	MultiplicativeExpression (=> ({ResultExpression.left=current} feature=('+' | '-')) right=MultiplicativeExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression (=> ({ResultExpression.left=current} feature=('+' | '-')) right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//(=> ({ResultExpression.left=current} feature=('+' | '-')) right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ResultExpression.left=current} feature=('+' | '-'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ResultExpression.left=current} feature=('+' | '-')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ResultExpression.left=current}
		public Action getResultExpressionLeftAction_1_0_0_0() { return cResultExpressionLeftAction_1_0_0_0; }
		
		//feature=('+' | '-')
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//('+' | '-')
		public Alternatives getFeatureAlternatives_1_0_0_1_0() { return cFeatureAlternatives_1_0_0_1_0; }
		
		//'+'
		public Keyword getFeaturePlusSignKeyword_1_0_0_1_0_0() { return cFeaturePlusSignKeyword_1_0_0_1_0_0; }
		
		//'-'
		public Keyword getFeatureHyphenMinusKeyword_1_0_0_1_0_1() { return cFeatureHyphenMinusKeyword_1_0_0_1_0_1; }
		
		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_1_0() { return cRightMultiplicativeExpressionParserRuleCall_1_1_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cResultExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_0_1_0 = (Alternatives)cFeatureAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cFeatureAsteriskKeyword_1_0_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(0);
		private final Keyword cFeatureAsteriskAsteriskKeyword_1_0_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(1);
		private final Keyword cFeatureSolidusKeyword_1_0_0_1_0_2 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(2);
		private final Keyword cFeaturePercentSignKeyword_1_0_0_1_0_3 = (Keyword)cFeatureAlternatives_1_0_0_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryOperationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MultiplicativeExpression ResultExpression:
		//	UnaryOperation (=> ({ResultExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*;
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryOperation (=> ({ResultExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*
		public Group getGroup() { return cGroup; }
		
		//UnaryOperation
		public RuleCall getUnaryOperationParserRuleCall_0() { return cUnaryOperationParserRuleCall_0; }
		
		//(=> ({ResultExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> ({ResultExpression.left=current} feature=('*' | '**' | '/' | '%'))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{ResultExpression.left=current} feature=('*' | '**' | '/' | '%')
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{ResultExpression.left=current}
		public Action getResultExpressionLeftAction_1_0_0_0() { return cResultExpressionLeftAction_1_0_0_0; }
		
		//feature=('*' | '**' | '/' | '%')
		public Assignment getFeatureAssignment_1_0_0_1() { return cFeatureAssignment_1_0_0_1; }
		
		//('*' | '**' | '/' | '%')
		public Alternatives getFeatureAlternatives_1_0_0_1_0() { return cFeatureAlternatives_1_0_0_1_0; }
		
		//'*'
		public Keyword getFeatureAsteriskKeyword_1_0_0_1_0_0() { return cFeatureAsteriskKeyword_1_0_0_1_0_0; }
		
		//'**'
		public Keyword getFeatureAsteriskAsteriskKeyword_1_0_0_1_0_1() { return cFeatureAsteriskAsteriskKeyword_1_0_0_1_0_1; }
		
		//'/'
		public Keyword getFeatureSolidusKeyword_1_0_0_1_0_2() { return cFeatureSolidusKeyword_1_0_0_1_0_2; }
		
		//'%'
		public Keyword getFeaturePercentSignKeyword_1_0_0_1_0_3() { return cFeaturePercentSignKeyword_1_0_0_1_0_3; }
		
		//right=UnaryOperation
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//UnaryOperation
		public RuleCall getRightUnaryOperationParserRuleCall_1_1_0() { return cRightUnaryOperationParserRuleCall_1_1_0; }
	}
	public class UnaryOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.UnaryOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryOperationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cFeatureAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cFeatureExclamationMarkKeyword_0_1_0 = (Keyword)cFeatureAssignment_0_1.eContents().get(0);
		private final Assignment cOperandAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperandUnaryOperationParserRuleCall_0_2_0 = (RuleCall)cOperandAssignment_0_2.eContents().get(0);
		private final RuleCall cPostfixOperationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// UnaryOperation -> (feature operand)
		//UnaryOperation ResultExpression:
		//	{UnaryOperation} feature='!' operand=UnaryOperation | PostfixOperation;
		@Override public ParserRule getRule() { return rule; }
		
		//{UnaryOperation} feature='!' operand=UnaryOperation | PostfixOperation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{UnaryOperation} feature='!' operand=UnaryOperation
		public Group getGroup_0() { return cGroup_0; }
		
		//{UnaryOperation}
		public Action getUnaryOperationAction_0_0() { return cUnaryOperationAction_0_0; }
		
		//feature='!'
		public Assignment getFeatureAssignment_0_1() { return cFeatureAssignment_0_1; }
		
		//'!'
		public Keyword getFeatureExclamationMarkKeyword_0_1_0() { return cFeatureExclamationMarkKeyword_0_1_0; }
		
		//operand=UnaryOperation
		public Assignment getOperandAssignment_0_2() { return cOperandAssignment_0_2; }
		
		//UnaryOperation
		public RuleCall getOperandUnaryOperationParserRuleCall_0_2_0() { return cOperandUnaryOperationParserRuleCall_0_2_0; }
		
		//PostfixOperation
		public RuleCall getPostfixOperationParserRuleCall_1() { return cPostfixOperationParserRuleCall_1; }
	}
	public class PostfixOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PostfixOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cUnaryOperationOperandAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cFeatureAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cFeatureAlternatives_1_0_1_0 = (Alternatives)cFeatureAssignment_1_0_1.eContents().get(0);
		private final Keyword cFeaturePlusSignPlusSignKeyword_1_0_1_0_0 = (Keyword)cFeatureAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cFeatureHyphenMinusHyphenMinusKeyword_1_0_1_0_1 = (Keyword)cFeatureAlternatives_1_0_1_0.eContents().get(1);
		
		//PostfixOperation ResultExpression:
		//	BaseExpression => ({UnaryOperation.operand=current} feature=('++' | '--'))?;
		@Override public ParserRule getRule() { return rule; }
		
		//BaseExpression => ({UnaryOperation.operand=current} feature=('++' | '--'))?
		public Group getGroup() { return cGroup; }
		
		//BaseExpression
		public RuleCall getBaseExpressionParserRuleCall_0() { return cBaseExpressionParserRuleCall_0; }
		
		//=> ({UnaryOperation.operand=current} feature=('++' | '--'))?
		public Group getGroup_1() { return cGroup_1; }
		
		//{UnaryOperation.operand=current} feature=('++' | '--')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{UnaryOperation.operand=current}
		public Action getUnaryOperationOperandAction_1_0_0() { return cUnaryOperationOperandAction_1_0_0; }
		
		//feature=('++' | '--')
		public Assignment getFeatureAssignment_1_0_1() { return cFeatureAssignment_1_0_1; }
		
		//('++' | '--')
		public Alternatives getFeatureAlternatives_1_0_1_0() { return cFeatureAlternatives_1_0_1_0; }
		
		//'++'
		public Keyword getFeaturePlusSignPlusSignKeyword_1_0_1_0_0() { return cFeaturePlusSignPlusSignKeyword_1_0_1_0_0; }
		
		//'--'
		public Keyword getFeatureHyphenMinusHyphenMinusKeyword_1_0_1_0_1() { return cFeatureHyphenMinusHyphenMinusKeyword_1_0_1_0_1; }
	}
	public class BaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BaseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cResultExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BaseExpression ResultExpression:
		//	Primary | '(' ResultExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//Primary | '(' ResultExpression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//'(' ResultExpression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//ResultExpression
		public RuleCall getResultExpressionParserRuleCall_1_1() { return cResultExpressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueLiteralParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTargetAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final CrossReference cTargetLetValueCrossReference_1_0_0 = (CrossReference)cTargetAssignment_1_0.eContents().get(0);
		private final RuleCall cTargetLetValueIDTerminalRuleCall_1_0_0_1 = (RuleCall)cTargetLetValueCrossReference_1_0_0.eContents().get(1);
		private final Assignment cMembersAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMembersMemberGetParserRuleCall_1_1_0 = (RuleCall)cMembersAssignment_1_1.eContents().get(0);
		
		//Primary ResultExpression:
		//	value=Literal
		//	| => target=[LetValue] members+=MemberGet*;
		@Override public ParserRule getRule() { return rule; }
		
		//value=Literal | => target=[LetValue] members+=MemberGet*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=Literal
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_0_0() { return cValueLiteralParserRuleCall_0_0; }
		
		//=> target=[LetValue] members+=MemberGet*
		public Group getGroup_1() { return cGroup_1; }
		
		//=> target=[LetValue]
		public Assignment getTargetAssignment_1_0() { return cTargetAssignment_1_0; }
		
		//[LetValue]
		public CrossReference getTargetLetValueCrossReference_1_0_0() { return cTargetLetValueCrossReference_1_0_0; }
		
		//ID
		public RuleCall getTargetLetValueIDTerminalRuleCall_1_0_0_1() { return cTargetLetValueIDTerminalRuleCall_1_0_0_1; }
		
		//members+=MemberGet*
		public Assignment getMembersAssignment_1_1() { return cMembersAssignment_1_1; }
		
		//MemberGet
		public RuleCall getMembersMemberGetParserRuleCall_1_1_0() { return cMembersMemberGetParserRuleCall_1_1_0; }
	}
	public class MemberGetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MemberGet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Assignment cIsNullSafeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cIsNullSafeQuestionMarkFullStopKeyword_0_1_0 = (Keyword)cIsNullSafeAssignment_0_1.eContents().get(0);
		private final Assignment cMemberAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMemberIDTerminalRuleCall_1_0 = (RuleCall)cMemberAssignment_1.eContents().get(0);
		
		//MemberGet:
		//	('.' | isNullSafe?='?.') member=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//('.' | isNullSafe?='?.') member=ID
		public Group getGroup() { return cGroup; }
		
		//'.' | isNullSafe?='?.'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//isNullSafe?='?.'
		public Assignment getIsNullSafeAssignment_0_1() { return cIsNullSafeAssignment_0_1; }
		
		//'?.'
		public Keyword getIsNullSafeQuestionMarkFullStopKeyword_0_1_0() { return cIsNullSafeQuestionMarkFullStopKeyword_0_1_0; }
		
		//member=ID
		public Assignment getMemberAssignment_1() { return cMemberAssignment_1; }
		
		//ID
		public RuleCall getMemberIDTerminalRuleCall_1_0() { return cMemberIDTerminalRuleCall_1_0; }
	}
	public class DefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeDefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExternalDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///*
		//OperationCall:
		//  async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression
		//;*/ // ------------------------------------------------------------------------------------------------------------------------------
		//// Type Definitions
		//// ------------------------------------------------------------------------------------------------------------------------------
		///*LambdaDef:
		//  '#(' param=ElementDef ('->' result=ElementDef)? ')'
		//;*/ Definition:
		//	TypeDef | ExternalDef;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeDef | ExternalDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TypeDef
		public RuleCall getTypeDefParserRuleCall_0() { return cTypeDefParserRuleCall_0; }
		
		//ExternalDef
		public RuleCall getExternalDefParserRuleCall_1() { return cExternalDefParserRuleCall_1; }
	}
	public class TypeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TypeDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypedefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cParserAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final Alternatives cParserAlternatives_2_0_0_0 = (Alternatives)cParserAssignment_2_0_0.eContents().get(0);
		private final Keyword cParserMatchKeyword_2_0_0_0_0 = (Keyword)cParserAlternatives_2_0_0_0.eContents().get(0);
		private final Keyword cParserMaskKeyword_2_0_0_0_1 = (Keyword)cParserAlternatives_2_0_0_0.eContents().get(1);
		private final Assignment cCodeAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cCodeTEXTTerminalRuleCall_2_0_1_0 = (RuleCall)cCodeAssignment_2_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		
		//TypeDef:
		//	'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=ElementDef);
		@Override public ParserRule getRule() { return rule; }
		
		//'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=ElementDef)
		public Group getGroup() { return cGroup; }
		
		//'typedef'
		public Keyword getTypedefKeyword_0() { return cTypedefKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//parser=('match' | 'mask') code=TEXT | type=ElementDef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//parser=('match' | 'mask') code=TEXT
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//parser=('match' | 'mask')
		public Assignment getParserAssignment_2_0_0() { return cParserAssignment_2_0_0; }
		
		//('match' | 'mask')
		public Alternatives getParserAlternatives_2_0_0_0() { return cParserAlternatives_2_0_0_0; }
		
		//'match'
		public Keyword getParserMatchKeyword_2_0_0_0_0() { return cParserMatchKeyword_2_0_0_0_0; }
		
		//'mask'
		public Keyword getParserMaskKeyword_2_0_0_0_1() { return cParserMaskKeyword_2_0_0_0_1; }
		
		//code=TEXT
		public Assignment getCodeAssignment_2_0_1() { return cCodeAssignment_2_0_1; }
		
		//TEXT
		public RuleCall getCodeTEXTTerminalRuleCall_2_0_1_0() { return cCodeTEXTTerminalRuleCall_2_0_1_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_1_0() { return cTypeElementDefParserRuleCall_2_1_0; }
	}
	public class ElementDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ElementDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNativeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNativeNativeDefParserRuleCall_0_0 = (RuleCall)cNativeAssignment_0.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cRefDefinitionCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefDefinitionIDTerminalRuleCall_1_0_1 = (RuleCall)cRefDefinitionCrossReference_1_0.eContents().get(1);
		private final RuleCall cListDefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMapDefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cEnumDefParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//ElementDef:
		//	native=NativeDef
		//	| ref=[Definition] | ListDef
		//	| MapDef
		//	| EnumDef;
		@Override public ParserRule getRule() { return rule; }
		
		//native=NativeDef | ref=[Definition] | ListDef | MapDef | EnumDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//native=NativeDef
		public Assignment getNativeAssignment_0() { return cNativeAssignment_0; }
		
		//NativeDef
		public RuleCall getNativeNativeDefParserRuleCall_0_0() { return cNativeNativeDefParserRuleCall_0_0; }
		
		//ref=[Definition]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }
		
		//[Definition]
		public CrossReference getRefDefinitionCrossReference_1_0() { return cRefDefinitionCrossReference_1_0; }
		
		//ID
		public RuleCall getRefDefinitionIDTerminalRuleCall_1_0_1() { return cRefDefinitionIDTerminalRuleCall_1_0_1; }
		
		//ListDef
		public RuleCall getListDefParserRuleCall_2() { return cListDefParserRuleCall_2; }
		
		//MapDef
		public RuleCall getMapDefParserRuleCall_3() { return cMapDefParserRuleCall_3; }
		
		//EnumDef
		public RuleCall getEnumDefParserRuleCall_4() { return cEnumDefParserRuleCall_4; }
	}
	public class MapDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Action cMapDefAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Assignment cDefsAssignment_0_0_2_0 = (Assignment)cGroup_0_0_2.eContents().get(0);
		private final RuleCall cDefsMapEntryDefParserRuleCall_0_0_2_0_0 = (RuleCall)cDefsAssignment_0_0_2_0.eContents().get(0);
		private final Group cGroup_0_0_2_1 = (Group)cGroup_0_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_0_0_2_1_0 = (Keyword)cGroup_0_0_2_1.eContents().get(0);
		private final Assignment cDefsAssignment_0_0_2_1_1 = (Assignment)cGroup_0_0_2_1.eContents().get(1);
		private final RuleCall cDefsMapEntryDefParserRuleCall_0_0_2_1_1_0 = (RuleCall)cDefsAssignment_0_0_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMapDefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cDefsAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cDefsMapEntryDefParserRuleCall_1_3_0_0 = (RuleCall)cDefsAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final RuleCall cBREAKParserRuleCall_1_3_1_0 = (RuleCall)cGroup_1_3_1.eContents().get(0);
		private final Assignment cDefsAssignment_1_3_1_1 = (Assignment)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cDefsMapEntryDefParserRuleCall_1_3_1_1_0 = (RuleCall)cDefsAssignment_1_3_1_1.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//MapDef:
		//	=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}') | {MapDef} '{'
		//	BEGIN (defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)?
		//	END
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}') | {MapDef} '{' BEGIN (defs+=MapEntryDef (BREAK
		//defs+=MapEntryDef)*)? END '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}')
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}'
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//{MapDef}
		public Action getMapDefAction_0_0_0() { return cMapDefAction_0_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0_1() { return cLeftCurlyBracketKeyword_0_0_1; }
		
		//(defs+=MapEntryDef (',' defs+=MapEntryDef)*)?
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_0_0_2_0() { return cDefsAssignment_0_0_2_0; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_0_0_2_0_0() { return cDefsMapEntryDefParserRuleCall_0_0_2_0_0; }
		
		//(',' defs+=MapEntryDef)*
		public Group getGroup_0_0_2_1() { return cGroup_0_0_2_1; }
		
		//','
		public Keyword getCommaKeyword_0_0_2_1_0() { return cCommaKeyword_0_0_2_1_0; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_0_0_2_1_1() { return cDefsAssignment_0_0_2_1_1; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_0_0_2_1_1_0() { return cDefsMapEntryDefParserRuleCall_0_0_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_0_3() { return cRightCurlyBracketKeyword_0_0_3; }
		
		//{MapDef} '{' BEGIN (defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)? END '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//{MapDef}
		public Action getMapDefAction_1_0() { return cMapDefAction_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1_2() { return cBEGINTerminalRuleCall_1_2; }
		
		//(defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_1_3_0() { return cDefsAssignment_1_3_0; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_1_3_0_0() { return cDefsMapEntryDefParserRuleCall_1_3_0_0; }
		
		//(BREAK defs+=MapEntryDef)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_1_3_1_0() { return cBREAKParserRuleCall_1_3_1_0; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_1_3_1_1() { return cDefsAssignment_1_3_1_1; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_1_3_1_1_0() { return cDefsMapEntryDefParserRuleCall_1_3_1_1_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_1_4() { return cENDTerminalRuleCall_1_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }
	}
	public class MapEntryDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapEntryDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cOptAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final Keyword cOptQuestionMarkKeyword_1_0_0_0 = (Keyword)cOptAssignment_1_0_0.eContents().get(0);
		private final Keyword cColonKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cTypeElementDefParserRuleCall_1_0_2_0 = (RuleCall)cTypeAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_1_1_0 = (RuleCall)cValueAssignment_1_1_1.eContents().get(0);
		
		//MapEntryDef:
		//	name=ID (opt?='?'? ':' type=ElementDef | '=' value=Literal);
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID (opt?='?'? ':' type=ElementDef | '=' value=Literal)
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//opt?='?'? ':' type=ElementDef | '=' value=Literal
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//opt?='?'? ':' type=ElementDef
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//opt?='?'?
		public Assignment getOptAssignment_1_0_0() { return cOptAssignment_1_0_0; }
		
		//'?'
		public Keyword getOptQuestionMarkKeyword_1_0_0_0() { return cOptQuestionMarkKeyword_1_0_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_0_1() { return cColonKeyword_1_0_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_1_0_2() { return cTypeAssignment_1_0_2; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_1_0_2_0() { return cTypeElementDefParserRuleCall_1_0_2_0; }
		
		//'=' value=Literal
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1_0() { return cEqualsSignKeyword_1_1_0; }
		
		//value=Literal
		public Assignment getValueAssignment_1_1_1() { return cValueAssignment_1_1_1; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_1_1_0() { return cValueLiteralParserRuleCall_1_1_1_0; }
	}
	public class ListDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ListDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListDefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeElementDefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//ListDef:
		//	{ListDef}
		//	'..' type=ElementDef;
		@Override public ParserRule getRule() { return rule; }
		
		//{ListDef} '..' type=ElementDef
		public Group getGroup() { return cGroup; }
		
		//{ListDef}
		public Action getListDefAction_0() { return cListDefAction_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_0() { return cTypeElementDefParserRuleCall_2_0; }
	}
	public class EnumDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeMapDefParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cDefsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDefsEnumItemDefParserRuleCall_4_0 = (RuleCall)cDefsAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//EnumDef:
		//	'enum' type=MapDef? ':'
		//	BEGIN
		//	defs+=EnumItemDef+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' type=MapDef? ':' BEGIN defs+=EnumItemDef+ END
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//type=MapDef?
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//MapDef
		public RuleCall getTypeMapDefParserRuleCall_1_0() { return cTypeMapDefParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//defs+=EnumItemDef+
		public Assignment getDefsAssignment_4() { return cDefsAssignment_4; }
		
		//EnumItemDef
		public RuleCall getDefsEnumItemDefParserRuleCall_4_0() { return cDefsEnumItemDefParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class EnumItemDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumItemDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueMapLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//EnumItemDef:
		//	name=ID value=MapLiteral?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID value=MapLiteral?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//value=MapLiteral?
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//MapLiteral
		public RuleCall getValueMapLiteralParserRuleCall_1_0() { return cValueMapLiteralParserRuleCall_1_0; }
	}
	public class NativeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.NativeDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAnyKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPathKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBoolKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cStrKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cIntKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFltKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLdaKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLtmKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLdtKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMapKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLstKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cEnumKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		//NativeDef:
		//	'any' | 'path'
		//	| 'bool' | 'str' | 'int' | 'flt'
		//	| 'lda' | 'ltm' | 'ldt'
		//	| 'map' | 'lst' | 'enum';
		@Override public ParserRule getRule() { return rule; }
		
		//'any' | 'path' | 'bool' | 'str' | 'int' | 'flt' | 'lda' | 'ltm' | 'ldt' | 'map' | 'lst' | 'enum'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'any'
		public Keyword getAnyKeyword_0() { return cAnyKeyword_0; }
		
		//'path'
		public Keyword getPathKeyword_1() { return cPathKeyword_1; }
		
		//'bool'
		public Keyword getBoolKeyword_2() { return cBoolKeyword_2; }
		
		//'str'
		public Keyword getStrKeyword_3() { return cStrKeyword_3; }
		
		//'int'
		public Keyword getIntKeyword_4() { return cIntKeyword_4; }
		
		//'flt'
		public Keyword getFltKeyword_5() { return cFltKeyword_5; }
		
		//'lda'
		public Keyword getLdaKeyword_6() { return cLdaKeyword_6; }
		
		//'ltm'
		public Keyword getLtmKeyword_7() { return cLtmKeyword_7; }
		
		//'ldt'
		public Keyword getLdtKeyword_8() { return cLdtKeyword_8; }
		
		//'map'
		public Keyword getMapKeyword_9() { return cMapKeyword_9; }
		
		//'lst'
		public Keyword getLstKeyword_10() { return cLstKeyword_10; }
		
		//'enum'
		public Keyword getEnumKeyword_11() { return cEnumKeyword_11; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBoolLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStrLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFltLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDateLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTimeLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cDateTimeLiteralParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cPathLiteralParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cListLiteralParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cMapLiteralParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEnumLiteralParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cPatternLiteralParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Literals
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Literal:
		//	BoolLiteral
		//	| StrLiteral
		//	| IntLiteral
		//	| FltLiteral
		//	| DateLiteral
		//	| TimeLiteral
		//	| DateTimeLiteral
		//	| PathLiteral
		//	| ListLiteral
		//	| MapLiteral
		//	| EnumLiteral
		//	| PatternLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//BoolLiteral | StrLiteral | IntLiteral | FltLiteral | DateLiteral | TimeLiteral | DateTimeLiteral | PathLiteral |
		//ListLiteral | MapLiteral | EnumLiteral | PatternLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BoolLiteral
		public RuleCall getBoolLiteralParserRuleCall_0() { return cBoolLiteralParserRuleCall_0; }
		
		//StrLiteral
		public RuleCall getStrLiteralParserRuleCall_1() { return cStrLiteralParserRuleCall_1; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_2() { return cIntLiteralParserRuleCall_2; }
		
		//FltLiteral
		public RuleCall getFltLiteralParserRuleCall_3() { return cFltLiteralParserRuleCall_3; }
		
		//DateLiteral
		public RuleCall getDateLiteralParserRuleCall_4() { return cDateLiteralParserRuleCall_4; }
		
		//TimeLiteral
		public RuleCall getTimeLiteralParserRuleCall_5() { return cTimeLiteralParserRuleCall_5; }
		
		//DateTimeLiteral
		public RuleCall getDateTimeLiteralParserRuleCall_6() { return cDateTimeLiteralParserRuleCall_6; }
		
		//PathLiteral
		public RuleCall getPathLiteralParserRuleCall_7() { return cPathLiteralParserRuleCall_7; }
		
		//ListLiteral
		public RuleCall getListLiteralParserRuleCall_8() { return cListLiteralParserRuleCall_8; }
		
		//MapLiteral
		public RuleCall getMapLiteralParserRuleCall_9() { return cMapLiteralParserRuleCall_9; }
		
		//EnumLiteral
		public RuleCall getEnumLiteralParserRuleCall_10() { return cEnumLiteralParserRuleCall_10; }
		
		//PatternLiteral
		public RuleCall getPatternLiteralParserRuleCall_11() { return cPatternLiteralParserRuleCall_11; }
	}
	public class BoolLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BoolLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cFalseKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Assignment cIsTrueAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cIsTrueTrueKeyword_1_1_0 = (Keyword)cIsTrueAssignment_1_1.eContents().get(0);
		
		//BoolLiteral:
		//	{BoolLiteral} ('false' | isTrue?='true');
		@Override public ParserRule getRule() { return rule; }
		
		//{BoolLiteral} ('false' | isTrue?='true')
		public Group getGroup() { return cGroup; }
		
		//{BoolLiteral}
		public Action getBoolLiteralAction_0() { return cBoolLiteralAction_0; }
		
		//'false' | isTrue?='true'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'false'
		public Keyword getFalseKeyword_1_0() { return cFalseKeyword_1_0; }
		
		//isTrue?='true'
		public Assignment getIsTrueAssignment_1_1() { return cIsTrueAssignment_1_1; }
		
		//'true'
		public Keyword getIsTrueTrueKeyword_1_1_0() { return cIsTrueTrueKeyword_1_1_0; }
	}
	public class StrLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.StrLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTEXTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StrLiteral:
		//	value=TEXT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TEXT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//TEXT
		public RuleCall getValueTEXTTerminalRuleCall_0() { return cValueTEXTTerminalRuleCall_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.IntLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNATURALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntLiteral:
		//	value=NATURAL;
		@Override public ParserRule getRule() { return rule; }
		
		//value=NATURAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//NATURAL
		public RuleCall getValueNATURALTerminalRuleCall_0() { return cValueNATURALTerminalRuleCall_0; }
	}
	public class FltLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FltLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//FltLiteral:
		//	value=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=FLOAT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_0() { return cValueFLOATTerminalRuleCall_0; }
	}
	public class DateLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DateLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateLiteral:
		//	value=DATE;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DATE
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DATE
		public RuleCall getValueDATETerminalRuleCall_0() { return cValueDATETerminalRuleCall_0; }
	}
	public class TimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TimeLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTIMETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//TimeLiteral:
		//	value=TIME;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TIME
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//TIME
		public RuleCall getValueTIMETerminalRuleCall_0() { return cValueTIMETerminalRuleCall_0; }
	}
	public class DateTimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DateTimeLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATETIMETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateTimeLiteral:
		//	value=DATETIME;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DATETIME
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DATETIME
		public RuleCall getValueDATETIMETerminalRuleCall_0() { return cValueDATETIMETerminalRuleCall_0; }
	}
	public class PathLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PathLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValuePATHTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//PathLiteral:
		//	value=PATH;
		@Override public ParserRule getRule() { return rule; }
		
		//value=PATH
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//PATH
		public RuleCall getValuePATHTerminalRuleCall_0() { return cValuePATHTerminalRuleCall_0; }
	}
	public class ListLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ListLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValsLiteralParserRuleCall_2_0_0 = (RuleCall)cValsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cValsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValsLiteralParserRuleCall_2_1_1_0 = (RuleCall)cValsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ListLiteral:
		//	{ListLiteral}
		//	'[' (vals+=Literal (',' vals+=Literal)*)? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{ListLiteral} '[' (vals+=Literal (',' vals+=Literal)*)? ']'
		public Group getGroup() { return cGroup; }
		
		//{ListLiteral}
		public Action getListLiteralAction_0() { return cListLiteralAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//(vals+=Literal (',' vals+=Literal)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//vals+=Literal
		public Assignment getValsAssignment_2_0() { return cValsAssignment_2_0; }
		
		//Literal
		public RuleCall getValsLiteralParserRuleCall_2_0_0() { return cValsLiteralParserRuleCall_2_0_0; }
		
		//(',' vals+=Literal)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//vals+=Literal
		public Assignment getValsAssignment_2_1_1() { return cValsAssignment_2_1_1; }
		
		//Literal
		public RuleCall getValsLiteralParserRuleCall_2_1_1_0() { return cValsLiteralParserRuleCall_2_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Action cMapLiteralAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Assignment cEntriesAssignment_0_0_2_0 = (Assignment)cGroup_0_0_2.eContents().get(0);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0 = (RuleCall)cEntriesAssignment_0_0_2_0.eContents().get(0);
		private final Group cGroup_0_0_2_1 = (Group)cGroup_0_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_0_0_2_1_0 = (Keyword)cGroup_0_0_2_1.eContents().get(0);
		private final Assignment cEntriesAssignment_0_0_2_1_1 = (Assignment)cGroup_0_0_2_1.eContents().get(1);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0 = (RuleCall)cEntriesAssignment_0_0_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMapLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cEntriesAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_1_3_0_0 = (RuleCall)cEntriesAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final RuleCall cBREAKParserRuleCall_1_3_1_0 = (RuleCall)cGroup_1_3_1.eContents().get(0);
		private final Assignment cEntriesAssignment_1_3_1_1 = (Assignment)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0 = (RuleCall)cEntriesAssignment_1_3_1_1.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//MapLiteral:
		//	=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{'
		//	BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
		//	END
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{' BEGIN
		//(entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)? END '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}')
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}'
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_0_0_0() { return cMapLiteralAction_0_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0_1() { return cLeftCurlyBracketKeyword_0_0_1; }
		
		//(entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)?
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_0_0_2_0() { return cEntriesAssignment_0_0_2_0; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0() { return cEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0; }
		
		//(',' entries+=MapEntryLiteral)*
		public Group getGroup_0_0_2_1() { return cGroup_0_0_2_1; }
		
		//','
		public Keyword getCommaKeyword_0_0_2_1_0() { return cCommaKeyword_0_0_2_1_0; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_0_0_2_1_1() { return cEntriesAssignment_0_0_2_1_1; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0() { return cEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_0_3() { return cRightCurlyBracketKeyword_0_0_3; }
		
		//{MapLiteral} '{' BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)? END '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_1_0() { return cMapLiteralAction_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1_2() { return cBEGINTerminalRuleCall_1_2; }
		
		//(entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_1_3_0() { return cEntriesAssignment_1_3_0; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_1_3_0_0() { return cEntriesMapEntryLiteralParserRuleCall_1_3_0_0; }
		
		//(BREAK entries+=MapEntryLiteral)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_1_3_1_0() { return cBREAKParserRuleCall_1_3_1_0; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_1_3_1_1() { return cEntriesAssignment_1_3_1_1; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0() { return cEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_1_4() { return cENDTerminalRuleCall_1_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }
	}
	public class MapEntryLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapEntryLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueLiteralParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//MapEntryLiteral:
		//	name=ID ':' value=Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' value=Literal
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//value=Literal
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_2_0() { return cValueLiteralParserRuleCall_2_0; }
	}
	public class EnumLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEnumLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCommercialAtKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRefEnumItemDefCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefEnumItemDefIDTerminalRuleCall_2_0_1 = (RuleCall)cRefEnumItemDefCrossReference_2_0.eContents().get(1);
		
		//EnumLiteral:
		//	{EnumLiteral}
		//	'@' ref=[EnumItemDef];
		@Override public ParserRule getRule() { return rule; }
		
		//{EnumLiteral} '@' ref=[EnumItemDef]
		public Group getGroup() { return cGroup; }
		
		//{EnumLiteral}
		public Action getEnumLiteralAction_0() { return cEnumLiteralAction_0; }
		
		//'@'
		public Keyword getCommercialAtKeyword_1() { return cCommercialAtKeyword_1; }
		
		//ref=[EnumItemDef]
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//[EnumItemDef]
		public CrossReference getRefEnumItemDefCrossReference_2_0() { return cRefEnumItemDefCrossReference_2_0; }
		
		//ID
		public RuleCall getRefEnumItemDefIDTerminalRuleCall_2_0_1() { return cRefEnumItemDefIDTerminalRuleCall_2_0_1; }
	}
	public class PatternLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PatternLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cNativeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cNativeNativeDefParserRuleCall_1_0_0 = (RuleCall)cNativeAssignment_1_0.eContents().get(0);
		private final Assignment cRefAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cRefDefinitionCrossReference_1_1_0 = (CrossReference)cRefAssignment_1_1.eContents().get(0);
		private final RuleCall cRefDefinitionIDTerminalRuleCall_1_1_0_1 = (RuleCall)cRefDefinitionCrossReference_1_1_0.eContents().get(1);
		private final Keyword cCommercialAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTextTEXTTerminalRuleCall_3_0 = (RuleCall)cTextAssignment_3.eContents().get(0);
		
		//PatternLiteral:
		//	{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT;
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT
		public Group getGroup() { return cGroup; }
		
		//{PatternLiteral}
		public Action getPatternLiteralAction_0() { return cPatternLiteralAction_0; }
		
		//native=NativeDef | ref=[Definition]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//native=NativeDef
		public Assignment getNativeAssignment_1_0() { return cNativeAssignment_1_0; }
		
		//NativeDef
		public RuleCall getNativeNativeDefParserRuleCall_1_0_0() { return cNativeNativeDefParserRuleCall_1_0_0; }
		
		//ref=[Definition]
		public Assignment getRefAssignment_1_1() { return cRefAssignment_1_1; }
		
		//[Definition]
		public CrossReference getRefDefinitionCrossReference_1_1_0() { return cRefDefinitionCrossReference_1_1_0; }
		
		//ID
		public RuleCall getRefDefinitionIDTerminalRuleCall_1_1_0_1() { return cRefDefinitionIDTerminalRuleCall_1_1_0_1; }
		
		//'@'
		public Keyword getCommercialAtKeyword_2() { return cCommercialAtKeyword_2; }
		
		//text=TEXT
		public Assignment getTextAssignment_3() { return cTextAssignment_3; }
		
		//TEXT
		public RuleCall getTextTEXTTerminalRuleCall_3_0() { return cTextTEXTTerminalRuleCall_3_0; }
	}
	public class BREAKElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BREAK");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLineFeedKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCarriageReturnKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BREAK:
		//	('\n' | '\r')*;
		@Override public ParserRule getRule() { return rule; }
		
		//('\n' | '\r')*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'\n'
		public Keyword getLineFeedKeyword_0() { return cLineFeedKeyword_0; }
		
		//'\r'
		public Keyword getCarriageReturnKeyword_1() { return cCarriageReturnKeyword_1; }
	}
	
	
	private final ModuleElements pModule;
	private final PlugDslElements pPlugDsl;
	private final ImportElements pImport;
	private final ImportOperationElements pImportOperation;
	private final ImportDefinitionElements pImportDefinition;
	private final ExternalDefElements pExternalDef;
	private final OperationElements pOperation;
	private final ParamDefElements pParamDef;
	private final SubPathElements pSubPath;
	private final BlockExpressionElements pBlockExpression;
	private final ExpressionElements pExpression;
	private final LetValueElements pLetValue;
	private final ResultExpressionElements pResultExpression;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final EqualityExpressionElements pEqualityExpression;
	private final RelationalExpressionElements pRelationalExpression;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final UnaryOperationElements pUnaryOperation;
	private final PostfixOperationElements pPostfixOperation;
	private final BaseExpressionElements pBaseExpression;
	private final PrimaryElements pPrimary;
	private final MemberGetElements pMemberGet;
	private final DefinitionElements pDefinition;
	private final TypeDefElements pTypeDef;
	private final ElementDefElements pElementDef;
	private final MapDefElements pMapDef;
	private final MapEntryDefElements pMapEntryDef;
	private final ListDefElements pListDef;
	private final EnumDefElements pEnumDef;
	private final EnumItemDefElements pEnumItemDef;
	private final NativeDefElements pNativeDef;
	private final LiteralElements pLiteral;
	private final BoolLiteralElements pBoolLiteral;
	private final StrLiteralElements pStrLiteral;
	private final IntLiteralElements pIntLiteral;
	private final FltLiteralElements pFltLiteral;
	private final DateLiteralElements pDateLiteral;
	private final TimeLiteralElements pTimeLiteral;
	private final DateTimeLiteralElements pDateTimeLiteral;
	private final PathLiteralElements pPathLiteral;
	private final ListLiteralElements pListLiteral;
	private final MapLiteralElements pMapLiteral;
	private final MapEntryLiteralElements pMapEntryLiteral;
	private final EnumLiteralElements pEnumLiteral;
	private final PatternLiteralElements pPatternLiteral;
	private final BREAKElements pBREAK;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tPATH;
	private final TerminalRule tID;
	private final TerminalRule tINT;
	private final TerminalRule tNATURAL;
	private final TerminalRule tFLOAT;
	private final TerminalRule tDATE;
	private final TerminalRule tTIME;
	private final TerminalRule tDATETIME;
	private final TerminalRule tTEXT;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public EldmDslGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModule = new ModuleElements();
		this.pPlugDsl = new PlugDslElements();
		this.pImport = new ImportElements();
		this.pImportOperation = new ImportOperationElements();
		this.pImportDefinition = new ImportDefinitionElements();
		this.pExternalDef = new ExternalDefElements();
		this.pOperation = new OperationElements();
		this.pParamDef = new ParamDefElements();
		this.pSubPath = new SubPathElements();
		this.pBlockExpression = new BlockExpressionElements();
		this.pExpression = new ExpressionElements();
		this.pLetValue = new LetValueElements();
		this.pResultExpression = new ResultExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pEqualityExpression = new EqualityExpressionElements();
		this.pRelationalExpression = new RelationalExpressionElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pUnaryOperation = new UnaryOperationElements();
		this.pPostfixOperation = new PostfixOperationElements();
		this.pBaseExpression = new BaseExpressionElements();
		this.pPrimary = new PrimaryElements();
		this.pMemberGet = new MemberGetElements();
		this.pDefinition = new DefinitionElements();
		this.pTypeDef = new TypeDefElements();
		this.pElementDef = new ElementDefElements();
		this.pMapDef = new MapDefElements();
		this.pMapEntryDef = new MapEntryDefElements();
		this.pListDef = new ListDefElements();
		this.pEnumDef = new EnumDefElements();
		this.pEnumItemDef = new EnumItemDefElements();
		this.pNativeDef = new NativeDefElements();
		this.pLiteral = new LiteralElements();
		this.pBoolLiteral = new BoolLiteralElements();
		this.pStrLiteral = new StrLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pFltLiteral = new FltLiteralElements();
		this.pDateLiteral = new DateLiteralElements();
		this.pTimeLiteral = new TimeLiteralElements();
		this.pDateTimeLiteral = new DateTimeLiteralElements();
		this.pPathLiteral = new PathLiteralElements();
		this.pListLiteral = new ListLiteralElements();
		this.pMapLiteral = new MapLiteralElements();
		this.pMapEntryLiteral = new MapEntryLiteralElements();
		this.pEnumLiteral = new EnumLiteralElements();
		this.pPatternLiteral = new PatternLiteralElements();
		this.pBREAK = new BREAKElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.END");
		this.tPATH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PATH");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ID");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.INT");
		this.tNATURAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.NATURAL");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FLOAT");
		this.tDATE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DATE");
		this.tTIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TIME");
		this.tDATETIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DATETIME");
		this.tTEXT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TEXT");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.eldm.EldmDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Module Header
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Module:
	//	'module' name=PathLiteral
	//	imports+=Import*
	//	plugs+=PlugDsl* ('definitions:'
	//	BEGIN
	//	defs+=Definition*
	//	vals+=LetValue*
	//	END)?
	//	opers+=Operation*
	//	paths+=SubPath*;
	public ModuleElements getModuleAccess() {
		return pModule;
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}
	
	//PlugDsl:
	//	'plug-dsl' name=ID adaptor=PatternLiteral;
	public PlugDslElements getPlugDslAccess() {
		return pPlugDsl;
	}
	
	public ParserRule getPlugDslRule() {
		return getPlugDslAccess().getRule();
	}
	
	//Import:
	//	ImportOperation | ImportDefinition;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ImportOperation Import:
	//	name=PathLiteral 'from' ref=PathLiteral;
	public ImportOperationElements getImportOperationAccess() {
		return pImportOperation;
	}
	
	public ParserRule getImportOperationRule() {
		return getImportOperationAccess().getRule();
	}
	
	//ImportDefinition Import:
	//	(defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral;
	public ImportDefinitionElements getImportDefinitionAccess() {
		return pImportDefinition;
	}
	
	public ParserRule getImportDefinitionRule() {
		return getImportDefinitionAccess().getRule();
	}
	
	//ExternalDef:
	//	ref=ID ('as' name=ID)? | => name=ID //TODO: check-if is a valid reference to a Definition ID
	//;
	public ExternalDefElements getExternalDefAccess() {
		return pExternalDef;
	}
	
	public ParserRule getExternalDefRule() {
		return getExternalDefAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Operations
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Operation:
	//	isPrivate?='private'? 'def' (isGet?='get' | 'set') name=PathLiteral? param=ParamDef? ('->' result=ElementDef)? ':'
	//	body=BlockExpression;
	public OperationElements getOperationAccess() {
		return pOperation;
	}
	
	public ParserRule getOperationRule() {
		return getOperationAccess().getRule();
	}
	
	//ParamDef:
	//	def=MapDef | ref=[MapDef];
	public ParamDefElements getParamDefAccess() {
		return pParamDef;
	}
	
	public ParserRule getParamDefRule() {
		return getParamDefAccess().getRule();
	}
	
	//SubPath:
	//	'def' name=PathLiteral
	//	BEGIN
	//	opers+=Operation+
	//	END;
	public SubPathElements getSubPathAccess() {
		return pSubPath;
	}
	
	public ParserRule getSubPathRule() {
		return getSubPathAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Expressions
	//// ------------------------------------------------------------------------------------------------------------------------------
	//BlockExpression:
	//	{BlockExpression} BEGIN
	//	expressions+=Expression*
	//	END;
	public BlockExpressionElements getBlockExpressionAccess() {
		return pBlockExpression;
	}
	
	public ParserRule getBlockExpressionRule() {
		return getBlockExpressionAccess().getRule();
	}
	
	//Expression:
	//	LetValue //TODO: add more expressions?
	//;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//LetValue:
	//	'let' name=ID (isTypeExplicit?=':' type=ElementDef)? '=' result=ResultExpression;
	public LetValueElements getLetValueAccess() {
		return pLetValue;
	}
	
	public ParserRule getLetValueRule() {
		return getLetValueAccess().getRule();
	}
	
	//// the result expression must be equivalent to a Literal
	//// ResultExpression -> (left feature right)
	//ResultExpression:
	//	OrExpression;
	public ResultExpressionElements getResultExpressionAccess() {
		return pResultExpression;
	}
	
	public ParserRule getResultExpressionRule() {
		return getResultExpressionAccess().getRule();
	}
	
	//OrExpression ResultExpression:
	//	AndExpression (=> ({ResultExpression.left=current} feature='or') right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//AndExpression ResultExpression:
	//	EqualityExpression (=> ({ResultExpression.left=current} feature='and') right=EqualityExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//EqualityExpression ResultExpression:
	//	RelationalExpression (=> ({ResultExpression.left=current} feature=('==' | '!=')) right=RelationalExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return pEqualityExpression;
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}
	
	//RelationalExpression ResultExpression:
	//	AdditiveExpression (=> ({IsExpression.expression=current} 'is') type=ElementDef
	//	| => ({ResultExpression.left=current} feature=('>=' | '<=' | '>' | '<')) right=AdditiveExpression)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return pRelationalExpression;
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}
	
	//AdditiveExpression ResultExpression:
	//	MultiplicativeExpression (=> ({ResultExpression.left=current} feature=('+' | '-')) right=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//MultiplicativeExpression ResultExpression:
	//	UnaryOperation (=> ({ResultExpression.left=current} feature=('*' | '**' | '/' | '%')) right=UnaryOperation)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//// UnaryOperation -> (feature operand)
	//UnaryOperation ResultExpression:
	//	{UnaryOperation} feature='!' operand=UnaryOperation | PostfixOperation;
	public UnaryOperationElements getUnaryOperationAccess() {
		return pUnaryOperation;
	}
	
	public ParserRule getUnaryOperationRule() {
		return getUnaryOperationAccess().getRule();
	}
	
	//PostfixOperation ResultExpression:
	//	BaseExpression => ({UnaryOperation.operand=current} feature=('++' | '--'))?;
	public PostfixOperationElements getPostfixOperationAccess() {
		return pPostfixOperation;
	}
	
	public ParserRule getPostfixOperationRule() {
		return getPostfixOperationAccess().getRule();
	}
	
	//BaseExpression ResultExpression:
	//	Primary | '(' ResultExpression ')';
	public BaseExpressionElements getBaseExpressionAccess() {
		return pBaseExpression;
	}
	
	public ParserRule getBaseExpressionRule() {
		return getBaseExpressionAccess().getRule();
	}
	
	//Primary ResultExpression:
	//	value=Literal
	//	| => target=[LetValue] members+=MemberGet*;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//MemberGet:
	//	('.' | isNullSafe?='?.') member=ID;
	public MemberGetElements getMemberGetAccess() {
		return pMemberGet;
	}
	
	public ParserRule getMemberGetRule() {
		return getMemberGetAccess().getRule();
	}
	
	///*
	//OperationCall:
	//  async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression
	//;*/ // ------------------------------------------------------------------------------------------------------------------------------
	//// Type Definitions
	//// ------------------------------------------------------------------------------------------------------------------------------
	///*LambdaDef:
	//  '#(' param=ElementDef ('->' result=ElementDef)? ')'
	//;*/ Definition:
	//	TypeDef | ExternalDef;
	public DefinitionElements getDefinitionAccess() {
		return pDefinition;
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}
	
	//TypeDef:
	//	'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=ElementDef);
	public TypeDefElements getTypeDefAccess() {
		return pTypeDef;
	}
	
	public ParserRule getTypeDefRule() {
		return getTypeDefAccess().getRule();
	}
	
	//ElementDef:
	//	native=NativeDef
	//	| ref=[Definition] | ListDef
	//	| MapDef
	//	| EnumDef;
	public ElementDefElements getElementDefAccess() {
		return pElementDef;
	}
	
	public ParserRule getElementDefRule() {
		return getElementDefAccess().getRule();
	}
	
	//MapDef:
	//	=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}') | {MapDef} '{'
	//	BEGIN (defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)?
	//	END
	//	'}';
	public MapDefElements getMapDefAccess() {
		return pMapDef;
	}
	
	public ParserRule getMapDefRule() {
		return getMapDefAccess().getRule();
	}
	
	//MapEntryDef:
	//	name=ID (opt?='?'? ':' type=ElementDef | '=' value=Literal);
	public MapEntryDefElements getMapEntryDefAccess() {
		return pMapEntryDef;
	}
	
	public ParserRule getMapEntryDefRule() {
		return getMapEntryDefAccess().getRule();
	}
	
	//ListDef:
	//	{ListDef}
	//	'..' type=ElementDef;
	public ListDefElements getListDefAccess() {
		return pListDef;
	}
	
	public ParserRule getListDefRule() {
		return getListDefAccess().getRule();
	}
	
	//EnumDef:
	//	'enum' type=MapDef? ':'
	//	BEGIN
	//	defs+=EnumItemDef+
	//	END;
	public EnumDefElements getEnumDefAccess() {
		return pEnumDef;
	}
	
	public ParserRule getEnumDefRule() {
		return getEnumDefAccess().getRule();
	}
	
	//EnumItemDef:
	//	name=ID value=MapLiteral?;
	public EnumItemDefElements getEnumItemDefAccess() {
		return pEnumItemDef;
	}
	
	public ParserRule getEnumItemDefRule() {
		return getEnumItemDefAccess().getRule();
	}
	
	//NativeDef:
	//	'any' | 'path'
	//	| 'bool' | 'str' | 'int' | 'flt'
	//	| 'lda' | 'ltm' | 'ldt'
	//	| 'map' | 'lst' | 'enum';
	public NativeDefElements getNativeDefAccess() {
		return pNativeDef;
	}
	
	public ParserRule getNativeDefRule() {
		return getNativeDefAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Literals
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Literal:
	//	BoolLiteral
	//	| StrLiteral
	//	| IntLiteral
	//	| FltLiteral
	//	| DateLiteral
	//	| TimeLiteral
	//	| DateTimeLiteral
	//	| PathLiteral
	//	| ListLiteral
	//	| MapLiteral
	//	| EnumLiteral
	//	| PatternLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BoolLiteral:
	//	{BoolLiteral} ('false' | isTrue?='true');
	public BoolLiteralElements getBoolLiteralAccess() {
		return pBoolLiteral;
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}
	
	//StrLiteral:
	//	value=TEXT;
	public StrLiteralElements getStrLiteralAccess() {
		return pStrLiteral;
	}
	
	public ParserRule getStrLiteralRule() {
		return getStrLiteralAccess().getRule();
	}
	
	//IntLiteral:
	//	value=NATURAL;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	//FltLiteral:
	//	value=FLOAT;
	public FltLiteralElements getFltLiteralAccess() {
		return pFltLiteral;
	}
	
	public ParserRule getFltLiteralRule() {
		return getFltLiteralAccess().getRule();
	}
	
	//DateLiteral:
	//	value=DATE;
	public DateLiteralElements getDateLiteralAccess() {
		return pDateLiteral;
	}
	
	public ParserRule getDateLiteralRule() {
		return getDateLiteralAccess().getRule();
	}
	
	//TimeLiteral:
	//	value=TIME;
	public TimeLiteralElements getTimeLiteralAccess() {
		return pTimeLiteral;
	}
	
	public ParserRule getTimeLiteralRule() {
		return getTimeLiteralAccess().getRule();
	}
	
	//DateTimeLiteral:
	//	value=DATETIME;
	public DateTimeLiteralElements getDateTimeLiteralAccess() {
		return pDateTimeLiteral;
	}
	
	public ParserRule getDateTimeLiteralRule() {
		return getDateTimeLiteralAccess().getRule();
	}
	
	//PathLiteral:
	//	value=PATH;
	public PathLiteralElements getPathLiteralAccess() {
		return pPathLiteral;
	}
	
	public ParserRule getPathLiteralRule() {
		return getPathLiteralAccess().getRule();
	}
	
	//ListLiteral:
	//	{ListLiteral}
	//	'[' (vals+=Literal (',' vals+=Literal)*)? ']';
	public ListLiteralElements getListLiteralAccess() {
		return pListLiteral;
	}
	
	public ParserRule getListLiteralRule() {
		return getListLiteralAccess().getRule();
	}
	
	//MapLiteral:
	//	=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{'
	//	BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
	//	END
	//	'}';
	public MapLiteralElements getMapLiteralAccess() {
		return pMapLiteral;
	}
	
	public ParserRule getMapLiteralRule() {
		return getMapLiteralAccess().getRule();
	}
	
	//MapEntryLiteral:
	//	name=ID ':' value=Literal;
	public MapEntryLiteralElements getMapEntryLiteralAccess() {
		return pMapEntryLiteral;
	}
	
	public ParserRule getMapEntryLiteralRule() {
		return getMapEntryLiteralAccess().getRule();
	}
	
	//EnumLiteral:
	//	{EnumLiteral}
	//	'@' ref=[EnumItemDef];
	public EnumLiteralElements getEnumLiteralAccess() {
		return pEnumLiteral;
	}
	
	public ParserRule getEnumLiteralRule() {
		return getEnumLiteralAccess().getRule();
	}
	
	//PatternLiteral:
	//	{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT;
	public PatternLiteralElements getPatternLiteralAccess() {
		return pPatternLiteral;
	}
	
	public ParserRule getPatternLiteralRule() {
		return getPatternLiteralAccess().getRule();
	}
	
	//BREAK:
	//	('\n' | '\r')*;
	public BREAKElements getBREAKAccess() {
		return pBREAK;
	}
	
	public ParserRule getBREAKRule() {
		return getBREAKAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal PATH:
	//	'/' ('a'..'z' | '-' | '0'..'9')+*;
	public TerminalRule getPATHRule() {
		return tPATH;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '-' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal INT:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal NATURAL:
	//	'-'? INT;
	public TerminalRule getNATURALRule() {
		return tNATURAL;
	}
	
	//terminal FLOAT:
	//	NATURAL ('.' INT)?;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal DATE:
	//	INT '-' ('0' '1'..'9' | '1' '0'..'2') '-' ('0' '1'..'9' | '1'..'2' '0'..'9' | '3' '0'..'1');
	public TerminalRule getDATERule() {
		return tDATE;
	}
	
	//terminal TIME:
	//	('0'..'1' '0'..'9' | '2' '0'..'3') ':' ('0'..'5' '0'..'9') ':' ('0'..'5' '0'..'9');
	public TerminalRule getTIMERule() {
		return tTIME;
	}
	
	//terminal DATETIME:
	//	DATE 'T' TIME;
	public TerminalRule getDATETIMERule() {
		return tDATETIME;
	}
	
	//terminal TEXT:
	//	"'" !("'" | '\r' | '\n')* "'" | '"""'->'"""';
	public TerminalRule getTEXTRule() {
		return tTEXT;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
