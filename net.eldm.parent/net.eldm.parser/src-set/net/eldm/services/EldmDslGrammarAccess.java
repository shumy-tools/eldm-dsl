/*
 * generated by Xtext 2.15.0
 */
package net.eldm.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class EldmDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePathLiteralParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cPlugsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPlugsPlugDslParserRuleCall_3_0 = (RuleCall)cPlugsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cDefinitionsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cDefsAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cDefsDefinitionParserRuleCall_4_2_0 = (RuleCall)cDefsAssignment_4_2.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4_3 = (RuleCall)cGroup_4.eContents().get(3);
		private final Assignment cOpersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cOpersOperationParserRuleCall_5_0 = (RuleCall)cOpersAssignment_5.eContents().get(0);
		private final Assignment cPathsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPathsSubPathParserRuleCall_6_0 = (RuleCall)cPathsAssignment_6.eContents().get(0);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Module Header
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Module:
		//	'module' name=PathLiteral
		//	imports+=Import*
		//	plugs+=PlugDsl* ('definitions:'
		//	BEGIN
		//	defs+=Definition+
		//	END)?
		//	opers+=Operation*
		//	paths+=SubPath*;
		@Override public ParserRule getRule() { return rule; }
		
		//'module' name=PathLiteral imports+=Import* plugs+=PlugDsl* ('definitions:' BEGIN defs+=Definition+ END)?
		//opers+=Operation* paths+=SubPath*
		public Group getGroup() { return cGroup; }
		
		//'module'
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_1_0() { return cNamePathLiteralParserRuleCall_1_0; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }
		
		//plugs+=PlugDsl*
		public Assignment getPlugsAssignment_3() { return cPlugsAssignment_3; }
		
		//PlugDsl
		public RuleCall getPlugsPlugDslParserRuleCall_3_0() { return cPlugsPlugDslParserRuleCall_3_0; }
		
		//('definitions:' BEGIN defs+=Definition+ END)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'definitions:'
		public Keyword getDefinitionsKeyword_4_0() { return cDefinitionsKeyword_4_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_4_1() { return cBEGINTerminalRuleCall_4_1; }
		
		//defs+=Definition+
		public Assignment getDefsAssignment_4_2() { return cDefsAssignment_4_2; }
		
		//Definition
		public RuleCall getDefsDefinitionParserRuleCall_4_2_0() { return cDefsDefinitionParserRuleCall_4_2_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4_3() { return cENDTerminalRuleCall_4_3; }
		
		//opers+=Operation*
		public Assignment getOpersAssignment_5() { return cOpersAssignment_5; }
		
		//Operation
		public RuleCall getOpersOperationParserRuleCall_5_0() { return cOpersOperationParserRuleCall_5_0; }
		
		//paths+=SubPath*
		public Assignment getPathsAssignment_6() { return cPathsAssignment_6; }
		
		//SubPath
		public RuleCall getPathsSubPathParserRuleCall_6_0() { return cPathsSubPathParserRuleCall_6_0; }
	}
	public class PlugDslElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PlugDsl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPlugDslKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cAdaptorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAdaptorPatternLiteralParserRuleCall_2_0 = (RuleCall)cAdaptorAssignment_2.eContents().get(0);
		
		//PlugDsl:
		//	'plug-dsl' name=ID adaptor=PatternLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//'plug-dsl' name=ID adaptor=PatternLiteral
		public Group getGroup() { return cGroup; }
		
		//'plug-dsl'
		public Keyword getPlugDslKeyword_0() { return cPlugDslKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//adaptor=PatternLiteral
		public Assignment getAdaptorAssignment_2() { return cAdaptorAssignment_2; }
		
		//PatternLiteral
		public RuleCall getAdaptorPatternLiteralParserRuleCall_2_0() { return cAdaptorPatternLiteralParserRuleCall_2_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Import");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImportOperationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cImportDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Import:
		//	ImportOperation | ImportDefinition;
		@Override public ParserRule getRule() { return rule; }
		
		//ImportOperation | ImportDefinition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ImportOperation
		public RuleCall getImportOperationParserRuleCall_0() { return cImportOperationParserRuleCall_0; }
		
		//ImportDefinition
		public RuleCall getImportDefinitionParserRuleCall_1() { return cImportDefinitionParserRuleCall_1; }
	}
	public class ImportOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ImportOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePathLiteralParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefPathLiteralParserRuleCall_2_0 = (RuleCall)cRefAssignment_2.eContents().get(0);
		
		//ImportOperation Import:
		//	name=PathLiteral 'from' ref=PathLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//name=PathLiteral 'from' ref=PathLiteral
		public Group getGroup() { return cGroup; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_0_0() { return cNamePathLiteralParserRuleCall_0_0; }
		
		//'from'
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }
		
		//ref=PathLiteral
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//PathLiteral
		public RuleCall getRefPathLiteralParserRuleCall_2_0() { return cRefPathLiteralParserRuleCall_2_0; }
	}
	public class ImportDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ImportDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cDefsAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cDefsExternalDefParserRuleCall_0_0_0 = (RuleCall)cDefsAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cDefsAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cDefsExternalDefParserRuleCall_0_1_1_0 = (RuleCall)cDefsAssignment_0_1_1.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefPathLiteralParserRuleCall_2_0 = (RuleCall)cRefAssignment_2.eContents().get(0);
		
		//ImportDefinition Import:
		//	(defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//(defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral
		public Group getGroup() { return cGroup; }
		
		//defs+=ExternalDef (',' defs+=ExternalDef)*
		public Group getGroup_0() { return cGroup_0; }
		
		//defs+=ExternalDef
		public Assignment getDefsAssignment_0_0() { return cDefsAssignment_0_0; }
		
		//ExternalDef
		public RuleCall getDefsExternalDefParserRuleCall_0_0_0() { return cDefsExternalDefParserRuleCall_0_0_0; }
		
		//(',' defs+=ExternalDef)*
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//','
		public Keyword getCommaKeyword_0_1_0() { return cCommaKeyword_0_1_0; }
		
		//defs+=ExternalDef
		public Assignment getDefsAssignment_0_1_1() { return cDefsAssignment_0_1_1; }
		
		//ExternalDef
		public RuleCall getDefsExternalDefParserRuleCall_0_1_1_0() { return cDefsExternalDefParserRuleCall_0_1_1_0; }
		
		//'from'
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }
		
		//ref=PathLiteral
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//PathLiteral
		public RuleCall getRefPathLiteralParserRuleCall_2_0() { return cRefPathLiteralParserRuleCall_2_0; }
	}
	public class ExternalDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ExternalDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cRefAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cRefIDTerminalRuleCall_0_0_0 = (RuleCall)cRefAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cAsKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cNameAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0_1_1_0 = (RuleCall)cNameAssignment_0_1_1.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ExternalDef:
		//	ref=ID ('as' name=ID)? | => name=ID //TODO: check-if is a valid reference to a Definition ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref=ID ('as' name=ID)? | => name=ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ref=ID ('as' name=ID)?
		public Group getGroup_0() { return cGroup_0; }
		
		//ref=ID
		public Assignment getRefAssignment_0_0() { return cRefAssignment_0_0; }
		
		//ID
		public RuleCall getRefIDTerminalRuleCall_0_0_0() { return cRefIDTerminalRuleCall_0_0_0; }
		
		//('as' name=ID)?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'as'
		public Keyword getAsKeyword_0_1_0() { return cAsKeyword_0_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_0_1_1() { return cNameAssignment_0_1_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_1_0() { return cNameIDTerminalRuleCall_0_1_1_0; }
		
		//=> name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class SubPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.SubPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePathLiteralParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final RuleCall cBEGINTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cOpersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOpersOperationParserRuleCall_3_0 = (RuleCall)cOpersAssignment_3.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Operations
		//// ------------------------------------------------------------------------------------------------------------------------------
		//SubPath:
		//	'def' name=PathLiteral
		//	BEGIN
		//	opers+=Operation+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'def' name=PathLiteral BEGIN opers+=Operation+ END
		public Group getGroup() { return cGroup; }
		
		//'def'
		public Keyword getDefKeyword_0() { return cDefKeyword_0; }
		
		//name=PathLiteral
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_1_0() { return cNamePathLiteralParserRuleCall_1_0; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_2() { return cBEGINTerminalRuleCall_2; }
		
		//opers+=Operation+
		public Assignment getOpersAssignment_3() { return cOpersAssignment_3; }
		
		//Operation
		public RuleCall getOpersOperationParserRuleCall_3_0() { return cOpersOperationParserRuleCall_3_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_4() { return cENDTerminalRuleCall_4; }
	}
	public class OperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Operation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIsGetAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cIsGetGetKeyword_1_0_0 = (Keyword)cIsGetAssignment_1_0.eContents().get(0);
		private final Keyword cSetKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNamePathLiteralParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamParamDefParserRuleCall_3_0 = (RuleCall)cParamAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cResultAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cResultElementDefParserRuleCall_4_1_0 = (RuleCall)cResultAssignment_4_1.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyBlockExpressionParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		
		//Operation:
		//	'def' (isGet?='get' | 'set') name=PathLiteral? param=ParamDef? ('->' result=ElementDef)? ':'
		//	body=BlockExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'def' (isGet?='get' | 'set') name=PathLiteral? param=ParamDef? ('->' result=ElementDef)? ':' body=BlockExpression
		public Group getGroup() { return cGroup; }
		
		//'def'
		public Keyword getDefKeyword_0() { return cDefKeyword_0; }
		
		//isGet?='get' | 'set'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//isGet?='get'
		public Assignment getIsGetAssignment_1_0() { return cIsGetAssignment_1_0; }
		
		//'get'
		public Keyword getIsGetGetKeyword_1_0_0() { return cIsGetGetKeyword_1_0_0; }
		
		//'set'
		public Keyword getSetKeyword_1_1() { return cSetKeyword_1_1; }
		
		//name=PathLiteral?
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//PathLiteral
		public RuleCall getNamePathLiteralParserRuleCall_2_0() { return cNamePathLiteralParserRuleCall_2_0; }
		
		//param=ParamDef?
		public Assignment getParamAssignment_3() { return cParamAssignment_3; }
		
		//ParamDef
		public RuleCall getParamParamDefParserRuleCall_3_0() { return cParamParamDefParserRuleCall_3_0; }
		
		//('->' result=ElementDef)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_4_0() { return cHyphenMinusGreaterThanSignKeyword_4_0; }
		
		//result=ElementDef
		public Assignment getResultAssignment_4_1() { return cResultAssignment_4_1; }
		
		//ElementDef
		public RuleCall getResultElementDefParserRuleCall_4_1_0() { return cResultElementDefParserRuleCall_4_1_0; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//body=BlockExpression
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }
		
		//BlockExpression
		public RuleCall getBodyBlockExpressionParserRuleCall_6_0() { return cBodyBlockExpressionParserRuleCall_6_0; }
	}
	public class ParamDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ParamDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cDefAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cDefMapDefParserRuleCall_0_0 = (RuleCall)cDefAssignment_0.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cRefMapDefCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefMapDefIDTerminalRuleCall_1_0_1 = (RuleCall)cRefMapDefCrossReference_1_0.eContents().get(1);
		
		//ParamDef:
		//	def=MapDef | ref=[MapDef];
		@Override public ParserRule getRule() { return rule; }
		
		//def=MapDef | ref=[MapDef]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//def=MapDef
		public Assignment getDefAssignment_0() { return cDefAssignment_0; }
		
		//MapDef
		public RuleCall getDefMapDefParserRuleCall_0_0() { return cDefMapDefParserRuleCall_0_0; }
		
		//ref=[MapDef]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }
		
		//[MapDef]
		public CrossReference getRefMapDefCrossReference_1_0() { return cRefMapDefCrossReference_1_0; }
		
		//ID
		public RuleCall getRefMapDefIDTerminalRuleCall_1_0_1() { return cRefMapDefIDTerminalRuleCall_1_0_1; }
	}
	public class BlockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BlockExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cBlockKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cENDTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Expressions
		//// ------------------------------------------------------------------------------------------------------------------------------
		//BlockExpression:
		//	BEGIN
		//	'<block>'
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//BEGIN '<block>' END
		public Group getGroup() { return cGroup; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_0() { return cBEGINTerminalRuleCall_0; }
		
		//'<block>'
		public Keyword getBlockKeyword_1() { return cBlockKeyword_1; }
		
		//END
		public RuleCall getENDTerminalRuleCall_2() { return cENDTerminalRuleCall_2; }
	}
	public class VariableDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.VariableDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLetKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_1_0_0 = (RuleCall)cNameAssignment_0_1_0.eContents().get(0);
		private final Group cGroup_0_1_1 = (Group)cGroup_0_1.eContents().get(1);
		private final Keyword cColonKeyword_0_1_1_0 = (Keyword)cGroup_0_1_1.eContents().get(0);
		private final Assignment cTypeAssignment_0_1_1_1 = (Assignment)cGroup_0_1_1.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_0_1_1_1_0 = (RuleCall)cTypeAssignment_0_1_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_1_2 = (Keyword)cGroup_0_1.eContents().get(2);
		private final Assignment cRightAssignment_0_1_3 = (Assignment)cGroup_0_1.eContents().get(3);
		private final RuleCall cRightExpressionParserRuleCall_0_1_3_0 = (RuleCall)cRightAssignment_0_1_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cMutAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cMutMutKeyword_1_0_0 = (Keyword)cMutAssignment_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cColonKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cTypeAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_1_2_1_0 = (RuleCall)cTypeAssignment_1_2_1.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cEqualsSignKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cRightAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cRightExpressionParserRuleCall_1_3_1_0 = (RuleCall)cRightAssignment_1_3_1.eContents().get(0);
		
		//VariableDef:
		//	'let' (name=ID (':' type=ElementDef)? '=' right=Expression) | mut?='mut' name=ID (':' type=ElementDef)? ('='
		//	right=Expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'let' (name=ID (':' type=ElementDef)? '=' right=Expression) | mut?='mut' name=ID (':' type=ElementDef)? ('='
		//right=Expression)?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'let' (name=ID (':' type=ElementDef)? '=' right=Expression)
		public Group getGroup_0() { return cGroup_0; }
		
		//'let'
		public Keyword getLetKeyword_0_0() { return cLetKeyword_0_0; }
		
		//name=ID (':' type=ElementDef)? '=' right=Expression
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_0_1_0() { return cNameAssignment_0_1_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_0_0() { return cNameIDTerminalRuleCall_0_1_0_0; }
		
		//(':' type=ElementDef)?
		public Group getGroup_0_1_1() { return cGroup_0_1_1; }
		
		//':'
		public Keyword getColonKeyword_0_1_1_0() { return cColonKeyword_0_1_1_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_0_1_1_1() { return cTypeAssignment_0_1_1_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_0_1_1_1_0() { return cTypeElementDefParserRuleCall_0_1_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_1_2() { return cEqualsSignKeyword_0_1_2; }
		
		//right=Expression
		public Assignment getRightAssignment_0_1_3() { return cRightAssignment_0_1_3; }
		
		//Expression
		public RuleCall getRightExpressionParserRuleCall_0_1_3_0() { return cRightExpressionParserRuleCall_0_1_3_0; }
		
		//mut?='mut' name=ID (':' type=ElementDef)? ('=' right=Expression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//mut?='mut'
		public Assignment getMutAssignment_1_0() { return cMutAssignment_1_0; }
		
		//'mut'
		public Keyword getMutMutKeyword_1_0_0() { return cMutMutKeyword_1_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_1_0() { return cNameIDTerminalRuleCall_1_1_0; }
		
		//(':' type=ElementDef)?
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//':'
		public Keyword getColonKeyword_1_2_0() { return cColonKeyword_1_2_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_1_2_1() { return cTypeAssignment_1_2_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_1_2_1_0() { return cTypeElementDefParserRuleCall_1_2_1_0; }
		
		//('=' right=Expression)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_3_0() { return cEqualsSignKeyword_1_3_0; }
		
		//right=Expression
		public Assignment getRightAssignment_1_3_1() { return cRightAssignment_1_3_1; }
		
		//Expression
		public RuleCall getRightExpressionParserRuleCall_1_3_1_0() { return cRightExpressionParserRuleCall_1_3_1_0; }
	}
	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAsyncAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cAsyncAsyncKeyword_0_0 = (Keyword)cAsyncAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cIsGetAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cIsGetGetKeyword_1_0_0 = (Keyword)cIsGetAssignment_1_0.eContents().get(0);
		private final Keyword cSetKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRefOperationCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefOperationIDTerminalRuleCall_2_0_1 = (RuleCall)cRefOperationCrossReference_2_0.eContents().get(1);
		private final Assignment cParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamMapExpressionParserRuleCall_3_0 = (RuleCall)cParamAssignment_3.eContents().get(0);
		
		//OperationCall:
		//	async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression
		public Group getGroup() { return cGroup; }
		
		//async?='async'?
		public Assignment getAsyncAssignment_0() { return cAsyncAssignment_0; }
		
		//'async'
		public Keyword getAsyncAsyncKeyword_0_0() { return cAsyncAsyncKeyword_0_0; }
		
		//isGet?='get' | 'set'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//isGet?='get'
		public Assignment getIsGetAssignment_1_0() { return cIsGetAssignment_1_0; }
		
		//'get'
		public Keyword getIsGetGetKeyword_1_0_0() { return cIsGetGetKeyword_1_0_0; }
		
		//'set'
		public Keyword getSetKeyword_1_1() { return cSetKeyword_1_1; }
		
		//ref=[Operation]
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//[Operation]
		public CrossReference getRefOperationCrossReference_2_0() { return cRefOperationCrossReference_2_0; }
		
		//ID
		public RuleCall getRefOperationIDTerminalRuleCall_2_0_1() { return cRefOperationIDTerminalRuleCall_2_0_1; }
		
		//param=MapExpression
		public Assignment getParamAssignment_3() { return cParamAssignment_3; }
		
		//MapExpression
		public RuleCall getParamMapExpressionParserRuleCall_3_0() { return cParamMapExpressionParserRuleCall_3_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Expression");
		private final Keyword cExpKeyword = (Keyword)rule.eContents().get(1);
		
		//Expression:
		//	'<exp>';
		@Override public ParserRule getRule() { return rule; }
		
		//'<exp>'
		public Keyword getExpKeyword() { return cExpKeyword; }
	}
	public class MapExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapExpression");
		private final Keyword cTest10Keyword = (Keyword)rule.eContents().get(1);
		
		//MapExpression:
		//	'{test:10}';
		@Override public ParserRule getRule() { return rule; }
		
		//'{test:10}'
		public Keyword getTest10Keyword() { return cTest10Keyword; }
	}
	public class LambdaDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.LambdaDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParamAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParamElementDefParserRuleCall_1_0 = (RuleCall)cParamAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cResultAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cResultElementDefParserRuleCall_2_1_0 = (RuleCall)cResultAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// LiteralExpression //TODO: use for default params
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Type Definitions
		//// ------------------------------------------------------------------------------------------------------------------------------
		//LambdaDef:
		//	'#(' param=ElementDef ('->' result=ElementDef)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'#(' param=ElementDef ('->' result=ElementDef)? ')'
		public Group getGroup() { return cGroup; }
		
		//'#('
		public Keyword getNumberSignLeftParenthesisKeyword_0() { return cNumberSignLeftParenthesisKeyword_0; }
		
		//param=ElementDef
		public Assignment getParamAssignment_1() { return cParamAssignment_1; }
		
		//ElementDef
		public RuleCall getParamElementDefParserRuleCall_1_0() { return cParamElementDefParserRuleCall_1_0; }
		
		//('->' result=ElementDef)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2_0() { return cHyphenMinusGreaterThanSignKeyword_2_0; }
		
		//result=ElementDef
		public Assignment getResultAssignment_2_1() { return cResultAssignment_2_1; }
		
		//ElementDef
		public RuleCall getResultElementDefParserRuleCall_2_1_0() { return cResultElementDefParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class DefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeDefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExternalDefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Definition:
		//	TypeDef | ExternalDef;
		@Override public ParserRule getRule() { return rule; }
		
		//TypeDef | ExternalDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TypeDef
		public RuleCall getTypeDefParserRuleCall_0() { return cTypeDefParserRuleCall_0; }
		
		//ExternalDef
		public RuleCall getExternalDefParserRuleCall_1() { return cExternalDefParserRuleCall_1; }
	}
	public class TypeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TypeDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypedefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cParserAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final Alternatives cParserAlternatives_2_0_0_0 = (Alternatives)cParserAssignment_2_0_0.eContents().get(0);
		private final Keyword cParserMatchKeyword_2_0_0_0_0 = (Keyword)cParserAlternatives_2_0_0_0.eContents().get(0);
		private final Keyword cParserMaskKeyword_2_0_0_0_1 = (Keyword)cParserAlternatives_2_0_0_0.eContents().get(1);
		private final Assignment cCodeAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cCodeTEXTTerminalRuleCall_2_0_1_0 = (RuleCall)cCodeAssignment_2_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cTypeElementDefParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		
		//TypeDef:
		//	'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=ElementDef);
		@Override public ParserRule getRule() { return rule; }
		
		//'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=ElementDef)
		public Group getGroup() { return cGroup; }
		
		//'typedef'
		public Keyword getTypedefKeyword_0() { return cTypedefKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//parser=('match' | 'mask') code=TEXT | type=ElementDef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//parser=('match' | 'mask') code=TEXT
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//parser=('match' | 'mask')
		public Assignment getParserAssignment_2_0_0() { return cParserAssignment_2_0_0; }
		
		//('match' | 'mask')
		public Alternatives getParserAlternatives_2_0_0_0() { return cParserAlternatives_2_0_0_0; }
		
		//'match'
		public Keyword getParserMatchKeyword_2_0_0_0_0() { return cParserMatchKeyword_2_0_0_0_0; }
		
		//'mask'
		public Keyword getParserMaskKeyword_2_0_0_0_1() { return cParserMaskKeyword_2_0_0_0_1; }
		
		//code=TEXT
		public Assignment getCodeAssignment_2_0_1() { return cCodeAssignment_2_0_1; }
		
		//TEXT
		public RuleCall getCodeTEXTTerminalRuleCall_2_0_1_0() { return cCodeTEXTTerminalRuleCall_2_0_1_0; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_1_0() { return cTypeElementDefParserRuleCall_2_1_0; }
	}
	public class ElementDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ElementDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNativeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNativeNativeDefParserRuleCall_0_0 = (RuleCall)cNativeAssignment_0.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cRefDefinitionCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefDefinitionIDTerminalRuleCall_1_0_1 = (RuleCall)cRefDefinitionCrossReference_1_0.eContents().get(1);
		private final RuleCall cListDefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMapDefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cEnumDefParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//ElementDef:
		//	native=NativeDef
		//	| ref=[Definition] | ListDef
		//	| MapDef
		//	| EnumDef;
		@Override public ParserRule getRule() { return rule; }
		
		//native=NativeDef | ref=[Definition] | ListDef | MapDef | EnumDef
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//native=NativeDef
		public Assignment getNativeAssignment_0() { return cNativeAssignment_0; }
		
		//NativeDef
		public RuleCall getNativeNativeDefParserRuleCall_0_0() { return cNativeNativeDefParserRuleCall_0_0; }
		
		//ref=[Definition]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }
		
		//[Definition]
		public CrossReference getRefDefinitionCrossReference_1_0() { return cRefDefinitionCrossReference_1_0; }
		
		//ID
		public RuleCall getRefDefinitionIDTerminalRuleCall_1_0_1() { return cRefDefinitionIDTerminalRuleCall_1_0_1; }
		
		//ListDef
		public RuleCall getListDefParserRuleCall_2() { return cListDefParserRuleCall_2; }
		
		//MapDef
		public RuleCall getMapDefParserRuleCall_3() { return cMapDefParserRuleCall_3; }
		
		//EnumDef
		public RuleCall getEnumDefParserRuleCall_4() { return cEnumDefParserRuleCall_4; }
	}
	public class MapDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Action cMapDefAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Assignment cDefsAssignment_0_0_2_0 = (Assignment)cGroup_0_0_2.eContents().get(0);
		private final RuleCall cDefsMapEntryDefParserRuleCall_0_0_2_0_0 = (RuleCall)cDefsAssignment_0_0_2_0.eContents().get(0);
		private final Group cGroup_0_0_2_1 = (Group)cGroup_0_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_0_0_2_1_0 = (Keyword)cGroup_0_0_2_1.eContents().get(0);
		private final Assignment cDefsAssignment_0_0_2_1_1 = (Assignment)cGroup_0_0_2_1.eContents().get(1);
		private final RuleCall cDefsMapEntryDefParserRuleCall_0_0_2_1_1_0 = (RuleCall)cDefsAssignment_0_0_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMapDefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cDefsAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cDefsMapEntryDefParserRuleCall_1_3_0_0 = (RuleCall)cDefsAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final RuleCall cBREAKParserRuleCall_1_3_1_0 = (RuleCall)cGroup_1_3_1.eContents().get(0);
		private final Assignment cDefsAssignment_1_3_1_1 = (Assignment)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cDefsMapEntryDefParserRuleCall_1_3_1_1_0 = (RuleCall)cDefsAssignment_1_3_1_1.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//MapDef:
		//	=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}') | {MapDef} '{'
		//	BEGIN (defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)?
		//	END
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}') | {MapDef} '{' BEGIN (defs+=MapEntryDef (BREAK
		//defs+=MapEntryDef)*)? END '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}')
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}'
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//{MapDef}
		public Action getMapDefAction_0_0_0() { return cMapDefAction_0_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0_1() { return cLeftCurlyBracketKeyword_0_0_1; }
		
		//(defs+=MapEntryDef (',' defs+=MapEntryDef)*)?
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_0_0_2_0() { return cDefsAssignment_0_0_2_0; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_0_0_2_0_0() { return cDefsMapEntryDefParserRuleCall_0_0_2_0_0; }
		
		//(',' defs+=MapEntryDef)*
		public Group getGroup_0_0_2_1() { return cGroup_0_0_2_1; }
		
		//','
		public Keyword getCommaKeyword_0_0_2_1_0() { return cCommaKeyword_0_0_2_1_0; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_0_0_2_1_1() { return cDefsAssignment_0_0_2_1_1; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_0_0_2_1_1_0() { return cDefsMapEntryDefParserRuleCall_0_0_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_0_3() { return cRightCurlyBracketKeyword_0_0_3; }
		
		//{MapDef} '{' BEGIN (defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)? END '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//{MapDef}
		public Action getMapDefAction_1_0() { return cMapDefAction_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1_2() { return cBEGINTerminalRuleCall_1_2; }
		
		//(defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_1_3_0() { return cDefsAssignment_1_3_0; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_1_3_0_0() { return cDefsMapEntryDefParserRuleCall_1_3_0_0; }
		
		//(BREAK defs+=MapEntryDef)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_1_3_1_0() { return cBREAKParserRuleCall_1_3_1_0; }
		
		//defs+=MapEntryDef
		public Assignment getDefsAssignment_1_3_1_1() { return cDefsAssignment_1_3_1_1; }
		
		//MapEntryDef
		public RuleCall getDefsMapEntryDefParserRuleCall_1_3_1_1_0() { return cDefsMapEntryDefParserRuleCall_1_3_1_1_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_1_4() { return cENDTerminalRuleCall_1_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }
	}
	public class MapEntryDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapEntryDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cOptAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final Keyword cOptQuestionMarkKeyword_1_0_0_0 = (Keyword)cOptAssignment_1_0_0.eContents().get(0);
		private final Keyword cColonKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cTypeElementDefParserRuleCall_1_0_2_0 = (RuleCall)cTypeAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_1_1_1_0 = (RuleCall)cValueAssignment_1_1_1.eContents().get(0);
		
		//MapEntryDef:
		//	name=ID (opt?='?'? ':' type=ElementDef | '=' value=Literal);
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID (opt?='?'? ':' type=ElementDef | '=' value=Literal)
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//opt?='?'? ':' type=ElementDef | '=' value=Literal
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//opt?='?'? ':' type=ElementDef
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//opt?='?'?
		public Assignment getOptAssignment_1_0_0() { return cOptAssignment_1_0_0; }
		
		//'?'
		public Keyword getOptQuestionMarkKeyword_1_0_0_0() { return cOptQuestionMarkKeyword_1_0_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_0_1() { return cColonKeyword_1_0_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_1_0_2() { return cTypeAssignment_1_0_2; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_1_0_2_0() { return cTypeElementDefParserRuleCall_1_0_2_0; }
		
		//'=' value=Literal
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1_0() { return cEqualsSignKeyword_1_1_0; }
		
		//value=Literal
		public Assignment getValueAssignment_1_1_1() { return cValueAssignment_1_1_1; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_1_1_1_0() { return cValueLiteralParserRuleCall_1_1_1_0; }
	}
	public class ListDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ListDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListDefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeElementDefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//ListDef:
		//	{ListDef}
		//	'..' type=ElementDef;
		@Override public ParserRule getRule() { return rule; }
		
		//{ListDef} '..' type=ElementDef
		public Group getGroup() { return cGroup; }
		
		//{ListDef}
		public Action getListDefAction_0() { return cListDefAction_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//type=ElementDef
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//ElementDef
		public RuleCall getTypeElementDefParserRuleCall_2_0() { return cTypeElementDefParserRuleCall_2_0; }
	}
	public class EnumDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeMapDefParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cBEGINTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cDefsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDefsEnumItemDefParserRuleCall_4_0 = (RuleCall)cDefsAssignment_4.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//EnumDef:
		//	'enum' type=MapDef ':'
		//	BEGIN
		//	defs+=EnumItemDef+
		//	END;
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' type=MapDef ':' BEGIN defs+=EnumItemDef+ END
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//type=MapDef
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//MapDef
		public RuleCall getTypeMapDefParserRuleCall_1_0() { return cTypeMapDefParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_3() { return cBEGINTerminalRuleCall_3; }
		
		//defs+=EnumItemDef+
		public Assignment getDefsAssignment_4() { return cDefsAssignment_4; }
		
		//EnumItemDef
		public RuleCall getDefsEnumItemDefParserRuleCall_4_0() { return cDefsEnumItemDefParserRuleCall_4_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_5() { return cENDTerminalRuleCall_5; }
	}
	public class EnumItemDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumItemDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueMapLiteralParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//EnumItemDef:
		//	name=ID value=MapLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID value=MapLiteral
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//value=MapLiteral
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//MapLiteral
		public RuleCall getValueMapLiteralParserRuleCall_1_0() { return cValueMapLiteralParserRuleCall_1_0; }
	}
	public class NativeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.NativeDef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAnyKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPathKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBoolKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cStrKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cIntKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFltKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLdaKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLtmKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLdtKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMapKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLstKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cEnumKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		//NativeDef:
		//	'any' | 'path'
		//	| 'bool' | 'str' | 'int' | 'flt'
		//	| 'lda' | 'ltm' | 'ldt'
		//	| 'map' | 'lst' | 'enum';
		@Override public ParserRule getRule() { return rule; }
		
		//'any' | 'path' | 'bool' | 'str' | 'int' | 'flt' | 'lda' | 'ltm' | 'ldt' | 'map' | 'lst' | 'enum'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'any'
		public Keyword getAnyKeyword_0() { return cAnyKeyword_0; }
		
		//'path'
		public Keyword getPathKeyword_1() { return cPathKeyword_1; }
		
		//'bool'
		public Keyword getBoolKeyword_2() { return cBoolKeyword_2; }
		
		//'str'
		public Keyword getStrKeyword_3() { return cStrKeyword_3; }
		
		//'int'
		public Keyword getIntKeyword_4() { return cIntKeyword_4; }
		
		//'flt'
		public Keyword getFltKeyword_5() { return cFltKeyword_5; }
		
		//'lda'
		public Keyword getLdaKeyword_6() { return cLdaKeyword_6; }
		
		//'ltm'
		public Keyword getLtmKeyword_7() { return cLtmKeyword_7; }
		
		//'ldt'
		public Keyword getLdtKeyword_8() { return cLdtKeyword_8; }
		
		//'map'
		public Keyword getMapKeyword_9() { return cMapKeyword_9; }
		
		//'lst'
		public Keyword getLstKeyword_10() { return cLstKeyword_10; }
		
		//'enum'
		public Keyword getEnumKeyword_11() { return cEnumKeyword_11; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBoolLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStrLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFltLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDateLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTimeLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cDateTimeLiteralParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cPathLiteralParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cListLiteralParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cMapLiteralParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEnumLiteralParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cPatternLiteralParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//// ------------------------------------------------------------------------------------------------------------------------------
		//// Literals
		//// ------------------------------------------------------------------------------------------------------------------------------
		//Literal:
		//	BoolLiteral
		//	| StrLiteral
		//	| IntLiteral
		//	| FltLiteral
		//	| DateLiteral
		//	| TimeLiteral
		//	| DateTimeLiteral
		//	| PathLiteral
		//	| ListLiteral
		//	| MapLiteral
		//	| EnumLiteral
		//	| PatternLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//BoolLiteral | StrLiteral | IntLiteral | FltLiteral | DateLiteral | TimeLiteral | DateTimeLiteral | PathLiteral |
		//ListLiteral | MapLiteral | EnumLiteral | PatternLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BoolLiteral
		public RuleCall getBoolLiteralParserRuleCall_0() { return cBoolLiteralParserRuleCall_0; }
		
		//StrLiteral
		public RuleCall getStrLiteralParserRuleCall_1() { return cStrLiteralParserRuleCall_1; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_2() { return cIntLiteralParserRuleCall_2; }
		
		//FltLiteral
		public RuleCall getFltLiteralParserRuleCall_3() { return cFltLiteralParserRuleCall_3; }
		
		//DateLiteral
		public RuleCall getDateLiteralParserRuleCall_4() { return cDateLiteralParserRuleCall_4; }
		
		//TimeLiteral
		public RuleCall getTimeLiteralParserRuleCall_5() { return cTimeLiteralParserRuleCall_5; }
		
		//DateTimeLiteral
		public RuleCall getDateTimeLiteralParserRuleCall_6() { return cDateTimeLiteralParserRuleCall_6; }
		
		//PathLiteral
		public RuleCall getPathLiteralParserRuleCall_7() { return cPathLiteralParserRuleCall_7; }
		
		//ListLiteral
		public RuleCall getListLiteralParserRuleCall_8() { return cListLiteralParserRuleCall_8; }
		
		//MapLiteral
		public RuleCall getMapLiteralParserRuleCall_9() { return cMapLiteralParserRuleCall_9; }
		
		//EnumLiteral
		public RuleCall getEnumLiteralParserRuleCall_10() { return cEnumLiteralParserRuleCall_10; }
		
		//PatternLiteral
		public RuleCall getPatternLiteralParserRuleCall_11() { return cPatternLiteralParserRuleCall_11; }
	}
	public class BoolLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BoolLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cFalseKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Assignment cIsTrueAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cIsTrueTrueKeyword_1_1_0 = (Keyword)cIsTrueAssignment_1_1.eContents().get(0);
		
		//BoolLiteral:
		//	{BoolLiteral} ('false' | isTrue?='true');
		@Override public ParserRule getRule() { return rule; }
		
		//{BoolLiteral} ('false' | isTrue?='true')
		public Group getGroup() { return cGroup; }
		
		//{BoolLiteral}
		public Action getBoolLiteralAction_0() { return cBoolLiteralAction_0; }
		
		//'false' | isTrue?='true'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'false'
		public Keyword getFalseKeyword_1_0() { return cFalseKeyword_1_0; }
		
		//isTrue?='true'
		public Assignment getIsTrueAssignment_1_1() { return cIsTrueAssignment_1_1; }
		
		//'true'
		public Keyword getIsTrueTrueKeyword_1_1_0() { return cIsTrueTrueKeyword_1_1_0; }
	}
	public class StrLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.StrLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTEXTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StrLiteral:
		//	value=TEXT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TEXT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//TEXT
		public RuleCall getValueTEXTTerminalRuleCall_0() { return cValueTEXTTerminalRuleCall_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.IntLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNATURALTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntLiteral:
		//	value=NATURAL;
		@Override public ParserRule getRule() { return rule; }
		
		//value=NATURAL
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//NATURAL
		public RuleCall getValueNATURALTerminalRuleCall_0() { return cValueNATURALTerminalRuleCall_0; }
	}
	public class FltLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FltLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//FltLiteral:
		//	value=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=FLOAT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_0() { return cValueFLOATTerminalRuleCall_0; }
	}
	public class DateLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DateLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateLiteral:
		//	value=DATE;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DATE
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DATE
		public RuleCall getValueDATETerminalRuleCall_0() { return cValueDATETerminalRuleCall_0; }
	}
	public class TimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TimeLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTIMETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//TimeLiteral:
		//	value=TIME;
		@Override public ParserRule getRule() { return rule; }
		
		//value=TIME
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//TIME
		public RuleCall getValueTIMETerminalRuleCall_0() { return cValueTIMETerminalRuleCall_0; }
	}
	public class DateTimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DateTimeLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATETIMETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//DateTimeLiteral:
		//	value=DATETIME;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DATETIME
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DATETIME
		public RuleCall getValueDATETIMETerminalRuleCall_0() { return cValueDATETIMETerminalRuleCall_0; }
	}
	public class PathLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PathLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValuePATHTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//PathLiteral:
		//	value=PATH;
		@Override public ParserRule getRule() { return rule; }
		
		//value=PATH
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//PATH
		public RuleCall getValuePATHTerminalRuleCall_0() { return cValuePATHTerminalRuleCall_0; }
	}
	public class ListLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ListLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValsLiteralParserRuleCall_2_0_0 = (RuleCall)cValsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cValsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValsLiteralParserRuleCall_2_1_1_0 = (RuleCall)cValsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ListLiteral:
		//	{ListLiteral}
		//	'[' (vals+=Literal (',' vals+=Literal)*)? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{ListLiteral} '[' (vals+=Literal (',' vals+=Literal)*)? ']'
		public Group getGroup() { return cGroup; }
		
		//{ListLiteral}
		public Action getListLiteralAction_0() { return cListLiteralAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//(vals+=Literal (',' vals+=Literal)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//vals+=Literal
		public Assignment getValsAssignment_2_0() { return cValsAssignment_2_0; }
		
		//Literal
		public RuleCall getValsLiteralParserRuleCall_2_0_0() { return cValsLiteralParserRuleCall_2_0_0; }
		
		//(',' vals+=Literal)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//vals+=Literal
		public Assignment getValsAssignment_2_1_1() { return cValsAssignment_2_1_1; }
		
		//Literal
		public RuleCall getValsLiteralParserRuleCall_2_1_1_0() { return cValsLiteralParserRuleCall_2_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cGroup_0.eContents().get(0);
		private final Action cMapLiteralAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_0_2 = (Group)cGroup_0_0.eContents().get(2);
		private final Assignment cEntriesAssignment_0_0_2_0 = (Assignment)cGroup_0_0_2.eContents().get(0);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0 = (RuleCall)cEntriesAssignment_0_0_2_0.eContents().get(0);
		private final Group cGroup_0_0_2_1 = (Group)cGroup_0_0_2.eContents().get(1);
		private final Keyword cCommaKeyword_0_0_2_1_0 = (Keyword)cGroup_0_0_2_1.eContents().get(0);
		private final Assignment cEntriesAssignment_0_0_2_1_1 = (Assignment)cGroup_0_0_2_1.eContents().get(1);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0 = (RuleCall)cEntriesAssignment_0_0_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMapLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBEGINTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cEntriesAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_1_3_0_0 = (RuleCall)cEntriesAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final RuleCall cBREAKParserRuleCall_1_3_1_0 = (RuleCall)cGroup_1_3_1.eContents().get(0);
		private final Assignment cEntriesAssignment_1_3_1_1 = (Assignment)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0 = (RuleCall)cEntriesAssignment_1_3_1_1.eContents().get(0);
		private final RuleCall cENDTerminalRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//MapLiteral:
		//	=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{'
		//	BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
		//	END
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{' BEGIN
		//(entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)? END '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}')
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}'
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_0_0_0() { return cMapLiteralAction_0_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0_1() { return cLeftCurlyBracketKeyword_0_0_1; }
		
		//(entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)?
		public Group getGroup_0_0_2() { return cGroup_0_0_2; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_0_0_2_0() { return cEntriesAssignment_0_0_2_0; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0() { return cEntriesMapEntryLiteralParserRuleCall_0_0_2_0_0; }
		
		//(',' entries+=MapEntryLiteral)*
		public Group getGroup_0_0_2_1() { return cGroup_0_0_2_1; }
		
		//','
		public Keyword getCommaKeyword_0_0_2_1_0() { return cCommaKeyword_0_0_2_1_0; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_0_0_2_1_1() { return cEntriesAssignment_0_0_2_1_1; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0() { return cEntriesMapEntryLiteralParserRuleCall_0_0_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_0_3() { return cRightCurlyBracketKeyword_0_0_3; }
		
		//{MapLiteral} '{' BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)? END '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_1_0() { return cMapLiteralAction_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }
		
		//BEGIN
		public RuleCall getBEGINTerminalRuleCall_1_2() { return cBEGINTerminalRuleCall_1_2; }
		
		//(entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_1_3_0() { return cEntriesAssignment_1_3_0; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_1_3_0_0() { return cEntriesMapEntryLiteralParserRuleCall_1_3_0_0; }
		
		//(BREAK entries+=MapEntryLiteral)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }
		
		//BREAK
		public RuleCall getBREAKParserRuleCall_1_3_1_0() { return cBREAKParserRuleCall_1_3_1_0; }
		
		//entries+=MapEntryLiteral
		public Assignment getEntriesAssignment_1_3_1_1() { return cEntriesAssignment_1_3_1_1; }
		
		//MapEntryLiteral
		public RuleCall getEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0() { return cEntriesMapEntryLiteralParserRuleCall_1_3_1_1_0; }
		
		//END
		public RuleCall getENDTerminalRuleCall_1_4() { return cENDTerminalRuleCall_1_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }
	}
	public class MapEntryLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.MapEntryLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueLiteralParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//MapEntryLiteral:
		//	name=ID ':' value=Literal;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' value=Literal
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//value=Literal
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Literal
		public RuleCall getValueLiteralParserRuleCall_2_0() { return cValueLiteralParserRuleCall_2_0; }
	}
	public class EnumLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.EnumLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEnumLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cRefEnumItemDefCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefEnumItemDefIDTerminalRuleCall_1_0_1 = (RuleCall)cRefEnumItemDefCrossReference_1_0.eContents().get(1);
		
		//EnumLiteral:
		//	{EnumLiteral} ref=[EnumItemDef];
		@Override public ParserRule getRule() { return rule; }
		
		//{EnumLiteral} ref=[EnumItemDef]
		public Group getGroup() { return cGroup; }
		
		//{EnumLiteral}
		public Action getEnumLiteralAction_0() { return cEnumLiteralAction_0; }
		
		//ref=[EnumItemDef]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }
		
		//[EnumItemDef]
		public CrossReference getRefEnumItemDefCrossReference_1_0() { return cRefEnumItemDefCrossReference_1_0; }
		
		//ID
		public RuleCall getRefEnumItemDefIDTerminalRuleCall_1_0_1() { return cRefEnumItemDefIDTerminalRuleCall_1_0_1; }
	}
	public class PatternLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PatternLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cNativeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cNativeNativeDefParserRuleCall_1_0_0 = (RuleCall)cNativeAssignment_1_0.eContents().get(0);
		private final Assignment cRefAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cRefDefinitionCrossReference_1_1_0 = (CrossReference)cRefAssignment_1_1.eContents().get(0);
		private final RuleCall cRefDefinitionIDTerminalRuleCall_1_1_0_1 = (RuleCall)cRefDefinitionCrossReference_1_1_0.eContents().get(1);
		private final Keyword cCommercialAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTextTEXTTerminalRuleCall_3_0 = (RuleCall)cTextAssignment_3.eContents().get(0);
		
		//PatternLiteral:
		//	{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT;
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT
		public Group getGroup() { return cGroup; }
		
		//{PatternLiteral}
		public Action getPatternLiteralAction_0() { return cPatternLiteralAction_0; }
		
		//native=NativeDef | ref=[Definition]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//native=NativeDef
		public Assignment getNativeAssignment_1_0() { return cNativeAssignment_1_0; }
		
		//NativeDef
		public RuleCall getNativeNativeDefParserRuleCall_1_0_0() { return cNativeNativeDefParserRuleCall_1_0_0; }
		
		//ref=[Definition]
		public Assignment getRefAssignment_1_1() { return cRefAssignment_1_1; }
		
		//[Definition]
		public CrossReference getRefDefinitionCrossReference_1_1_0() { return cRefDefinitionCrossReference_1_1_0; }
		
		//ID
		public RuleCall getRefDefinitionIDTerminalRuleCall_1_1_0_1() { return cRefDefinitionIDTerminalRuleCall_1_1_0_1; }
		
		//'@'
		public Keyword getCommercialAtKeyword_2() { return cCommercialAtKeyword_2; }
		
		//text=TEXT
		public Assignment getTextAssignment_3() { return cTextAssignment_3; }
		
		//TEXT
		public RuleCall getTextTEXTTerminalRuleCall_3_0() { return cTextTEXTTerminalRuleCall_3_0; }
	}
	public class BREAKElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BREAK");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLineFeedKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCarriageReturnKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BREAK:
		//	('\n' | '\r')*;
		@Override public ParserRule getRule() { return rule; }
		
		//('\n' | '\r')*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'\n'
		public Keyword getLineFeedKeyword_0() { return cLineFeedKeyword_0; }
		
		//'\r'
		public Keyword getCarriageReturnKeyword_1() { return cCarriageReturnKeyword_1; }
	}
	
	
	private final ModuleElements pModule;
	private final PlugDslElements pPlugDsl;
	private final ImportElements pImport;
	private final ImportOperationElements pImportOperation;
	private final ImportDefinitionElements pImportDefinition;
	private final ExternalDefElements pExternalDef;
	private final SubPathElements pSubPath;
	private final OperationElements pOperation;
	private final ParamDefElements pParamDef;
	private final BlockExpressionElements pBlockExpression;
	private final VariableDefElements pVariableDef;
	private final OperationCallElements pOperationCall;
	private final ExpressionElements pExpression;
	private final MapExpressionElements pMapExpression;
	private final LambdaDefElements pLambdaDef;
	private final DefinitionElements pDefinition;
	private final TypeDefElements pTypeDef;
	private final ElementDefElements pElementDef;
	private final MapDefElements pMapDef;
	private final MapEntryDefElements pMapEntryDef;
	private final ListDefElements pListDef;
	private final EnumDefElements pEnumDef;
	private final EnumItemDefElements pEnumItemDef;
	private final NativeDefElements pNativeDef;
	private final LiteralElements pLiteral;
	private final BoolLiteralElements pBoolLiteral;
	private final StrLiteralElements pStrLiteral;
	private final IntLiteralElements pIntLiteral;
	private final FltLiteralElements pFltLiteral;
	private final DateLiteralElements pDateLiteral;
	private final TimeLiteralElements pTimeLiteral;
	private final DateTimeLiteralElements pDateTimeLiteral;
	private final PathLiteralElements pPathLiteral;
	private final ListLiteralElements pListLiteral;
	private final MapLiteralElements pMapLiteral;
	private final MapEntryLiteralElements pMapEntryLiteral;
	private final EnumLiteralElements pEnumLiteral;
	private final PatternLiteralElements pPatternLiteral;
	private final BREAKElements pBREAK;
	private final TerminalRule tBEGIN;
	private final TerminalRule tEND;
	private final TerminalRule tPATH;
	private final TerminalRule tID;
	private final TerminalRule tINT;
	private final TerminalRule tNATURAL;
	private final TerminalRule tFLOAT;
	private final TerminalRule tDATE;
	private final TerminalRule tTIME;
	private final TerminalRule tDATETIME;
	private final TerminalRule tTEXT;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public EldmDslGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModule = new ModuleElements();
		this.pPlugDsl = new PlugDslElements();
		this.pImport = new ImportElements();
		this.pImportOperation = new ImportOperationElements();
		this.pImportDefinition = new ImportDefinitionElements();
		this.pExternalDef = new ExternalDefElements();
		this.pSubPath = new SubPathElements();
		this.pOperation = new OperationElements();
		this.pParamDef = new ParamDefElements();
		this.pBlockExpression = new BlockExpressionElements();
		this.pVariableDef = new VariableDefElements();
		this.pOperationCall = new OperationCallElements();
		this.pExpression = new ExpressionElements();
		this.pMapExpression = new MapExpressionElements();
		this.pLambdaDef = new LambdaDefElements();
		this.pDefinition = new DefinitionElements();
		this.pTypeDef = new TypeDefElements();
		this.pElementDef = new ElementDefElements();
		this.pMapDef = new MapDefElements();
		this.pMapEntryDef = new MapEntryDefElements();
		this.pListDef = new ListDefElements();
		this.pEnumDef = new EnumDefElements();
		this.pEnumItemDef = new EnumItemDefElements();
		this.pNativeDef = new NativeDefElements();
		this.pLiteral = new LiteralElements();
		this.pBoolLiteral = new BoolLiteralElements();
		this.pStrLiteral = new StrLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pFltLiteral = new FltLiteralElements();
		this.pDateLiteral = new DateLiteralElements();
		this.pTimeLiteral = new TimeLiteralElements();
		this.pDateTimeLiteral = new DateTimeLiteralElements();
		this.pPathLiteral = new PathLiteralElements();
		this.pListLiteral = new ListLiteralElements();
		this.pMapLiteral = new MapLiteralElements();
		this.pMapEntryLiteral = new MapEntryLiteralElements();
		this.pEnumLiteral = new EnumLiteralElements();
		this.pPatternLiteral = new PatternLiteralElements();
		this.pBREAK = new BREAKElements();
		this.tBEGIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.BEGIN");
		this.tEND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.END");
		this.tPATH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.PATH");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ID");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.INT");
		this.tNATURAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.NATURAL");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.FLOAT");
		this.tDATE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DATE");
		this.tTIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TIME");
		this.tDATETIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.DATETIME");
		this.tTEXT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.TEXT");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.eldm.EldmDsl.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.eldm.EldmDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Module Header
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Module:
	//	'module' name=PathLiteral
	//	imports+=Import*
	//	plugs+=PlugDsl* ('definitions:'
	//	BEGIN
	//	defs+=Definition+
	//	END)?
	//	opers+=Operation*
	//	paths+=SubPath*;
	public ModuleElements getModuleAccess() {
		return pModule;
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}
	
	//PlugDsl:
	//	'plug-dsl' name=ID adaptor=PatternLiteral;
	public PlugDslElements getPlugDslAccess() {
		return pPlugDsl;
	}
	
	public ParserRule getPlugDslRule() {
		return getPlugDslAccess().getRule();
	}
	
	//Import:
	//	ImportOperation | ImportDefinition;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//ImportOperation Import:
	//	name=PathLiteral 'from' ref=PathLiteral;
	public ImportOperationElements getImportOperationAccess() {
		return pImportOperation;
	}
	
	public ParserRule getImportOperationRule() {
		return getImportOperationAccess().getRule();
	}
	
	//ImportDefinition Import:
	//	(defs+=ExternalDef (',' defs+=ExternalDef)*) 'from' ref=PathLiteral;
	public ImportDefinitionElements getImportDefinitionAccess() {
		return pImportDefinition;
	}
	
	public ParserRule getImportDefinitionRule() {
		return getImportDefinitionAccess().getRule();
	}
	
	//ExternalDef:
	//	ref=ID ('as' name=ID)? | => name=ID //TODO: check-if is a valid reference to a Definition ID
	//;
	public ExternalDefElements getExternalDefAccess() {
		return pExternalDef;
	}
	
	public ParserRule getExternalDefRule() {
		return getExternalDefAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Operations
	//// ------------------------------------------------------------------------------------------------------------------------------
	//SubPath:
	//	'def' name=PathLiteral
	//	BEGIN
	//	opers+=Operation+
	//	END;
	public SubPathElements getSubPathAccess() {
		return pSubPath;
	}
	
	public ParserRule getSubPathRule() {
		return getSubPathAccess().getRule();
	}
	
	//Operation:
	//	'def' (isGet?='get' | 'set') name=PathLiteral? param=ParamDef? ('->' result=ElementDef)? ':'
	//	body=BlockExpression;
	public OperationElements getOperationAccess() {
		return pOperation;
	}
	
	public ParserRule getOperationRule() {
		return getOperationAccess().getRule();
	}
	
	//ParamDef:
	//	def=MapDef | ref=[MapDef];
	public ParamDefElements getParamDefAccess() {
		return pParamDef;
	}
	
	public ParserRule getParamDefRule() {
		return getParamDefAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Expressions
	//// ------------------------------------------------------------------------------------------------------------------------------
	//BlockExpression:
	//	BEGIN
	//	'<block>'
	//	END;
	public BlockExpressionElements getBlockExpressionAccess() {
		return pBlockExpression;
	}
	
	public ParserRule getBlockExpressionRule() {
		return getBlockExpressionAccess().getRule();
	}
	
	//VariableDef:
	//	'let' (name=ID (':' type=ElementDef)? '=' right=Expression) | mut?='mut' name=ID (':' type=ElementDef)? ('='
	//	right=Expression)?;
	public VariableDefElements getVariableDefAccess() {
		return pVariableDef;
	}
	
	public ParserRule getVariableDefRule() {
		return getVariableDefAccess().getRule();
	}
	
	//OperationCall:
	//	async?='async'? (isGet?='get' | 'set') ref=[Operation] param=MapExpression;
	public OperationCallElements getOperationCallAccess() {
		return pOperationCall;
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}
	
	//Expression:
	//	'<exp>';
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//MapExpression:
	//	'{test:10}';
	public MapExpressionElements getMapExpressionAccess() {
		return pMapExpression;
	}
	
	public ParserRule getMapExpressionRule() {
		return getMapExpressionAccess().getRule();
	}
	
	//// LiteralExpression //TODO: use for default params
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Type Definitions
	//// ------------------------------------------------------------------------------------------------------------------------------
	//LambdaDef:
	//	'#(' param=ElementDef ('->' result=ElementDef)? ')';
	public LambdaDefElements getLambdaDefAccess() {
		return pLambdaDef;
	}
	
	public ParserRule getLambdaDefRule() {
		return getLambdaDefAccess().getRule();
	}
	
	//Definition:
	//	TypeDef | ExternalDef;
	public DefinitionElements getDefinitionAccess() {
		return pDefinition;
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}
	
	//TypeDef:
	//	'typedef' name=ID (parser=('match' | 'mask') code=TEXT | type=ElementDef);
	public TypeDefElements getTypeDefAccess() {
		return pTypeDef;
	}
	
	public ParserRule getTypeDefRule() {
		return getTypeDefAccess().getRule();
	}
	
	//ElementDef:
	//	native=NativeDef
	//	| ref=[Definition] | ListDef
	//	| MapDef
	//	| EnumDef;
	public ElementDefElements getElementDefAccess() {
		return pElementDef;
	}
	
	public ParserRule getElementDefRule() {
		return getElementDefAccess().getRule();
	}
	
	//MapDef:
	//	=> ({MapDef} '{' (defs+=MapEntryDef (',' defs+=MapEntryDef)*)? '}') | {MapDef} '{'
	//	BEGIN (defs+=MapEntryDef (BREAK defs+=MapEntryDef)*)?
	//	END
	//	'}';
	public MapDefElements getMapDefAccess() {
		return pMapDef;
	}
	
	public ParserRule getMapDefRule() {
		return getMapDefAccess().getRule();
	}
	
	//MapEntryDef:
	//	name=ID (opt?='?'? ':' type=ElementDef | '=' value=Literal);
	public MapEntryDefElements getMapEntryDefAccess() {
		return pMapEntryDef;
	}
	
	public ParserRule getMapEntryDefRule() {
		return getMapEntryDefAccess().getRule();
	}
	
	//ListDef:
	//	{ListDef}
	//	'..' type=ElementDef;
	public ListDefElements getListDefAccess() {
		return pListDef;
	}
	
	public ParserRule getListDefRule() {
		return getListDefAccess().getRule();
	}
	
	//EnumDef:
	//	'enum' type=MapDef ':'
	//	BEGIN
	//	defs+=EnumItemDef+
	//	END;
	public EnumDefElements getEnumDefAccess() {
		return pEnumDef;
	}
	
	public ParserRule getEnumDefRule() {
		return getEnumDefAccess().getRule();
	}
	
	//EnumItemDef:
	//	name=ID value=MapLiteral;
	public EnumItemDefElements getEnumItemDefAccess() {
		return pEnumItemDef;
	}
	
	public ParserRule getEnumItemDefRule() {
		return getEnumItemDefAccess().getRule();
	}
	
	//NativeDef:
	//	'any' | 'path'
	//	| 'bool' | 'str' | 'int' | 'flt'
	//	| 'lda' | 'ltm' | 'ldt'
	//	| 'map' | 'lst' | 'enum';
	public NativeDefElements getNativeDefAccess() {
		return pNativeDef;
	}
	
	public ParserRule getNativeDefRule() {
		return getNativeDefAccess().getRule();
	}
	
	//// ------------------------------------------------------------------------------------------------------------------------------
	//// Literals
	//// ------------------------------------------------------------------------------------------------------------------------------
	//Literal:
	//	BoolLiteral
	//	| StrLiteral
	//	| IntLiteral
	//	| FltLiteral
	//	| DateLiteral
	//	| TimeLiteral
	//	| DateTimeLiteral
	//	| PathLiteral
	//	| ListLiteral
	//	| MapLiteral
	//	| EnumLiteral
	//	| PatternLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BoolLiteral:
	//	{BoolLiteral} ('false' | isTrue?='true');
	public BoolLiteralElements getBoolLiteralAccess() {
		return pBoolLiteral;
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}
	
	//StrLiteral:
	//	value=TEXT;
	public StrLiteralElements getStrLiteralAccess() {
		return pStrLiteral;
	}
	
	public ParserRule getStrLiteralRule() {
		return getStrLiteralAccess().getRule();
	}
	
	//IntLiteral:
	//	value=NATURAL;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	//FltLiteral:
	//	value=FLOAT;
	public FltLiteralElements getFltLiteralAccess() {
		return pFltLiteral;
	}
	
	public ParserRule getFltLiteralRule() {
		return getFltLiteralAccess().getRule();
	}
	
	//DateLiteral:
	//	value=DATE;
	public DateLiteralElements getDateLiteralAccess() {
		return pDateLiteral;
	}
	
	public ParserRule getDateLiteralRule() {
		return getDateLiteralAccess().getRule();
	}
	
	//TimeLiteral:
	//	value=TIME;
	public TimeLiteralElements getTimeLiteralAccess() {
		return pTimeLiteral;
	}
	
	public ParserRule getTimeLiteralRule() {
		return getTimeLiteralAccess().getRule();
	}
	
	//DateTimeLiteral:
	//	value=DATETIME;
	public DateTimeLiteralElements getDateTimeLiteralAccess() {
		return pDateTimeLiteral;
	}
	
	public ParserRule getDateTimeLiteralRule() {
		return getDateTimeLiteralAccess().getRule();
	}
	
	//PathLiteral:
	//	value=PATH;
	public PathLiteralElements getPathLiteralAccess() {
		return pPathLiteral;
	}
	
	public ParserRule getPathLiteralRule() {
		return getPathLiteralAccess().getRule();
	}
	
	//ListLiteral:
	//	{ListLiteral}
	//	'[' (vals+=Literal (',' vals+=Literal)*)? ']';
	public ListLiteralElements getListLiteralAccess() {
		return pListLiteral;
	}
	
	public ParserRule getListLiteralRule() {
		return getListLiteralAccess().getRule();
	}
	
	//MapLiteral:
	//	=> ({MapLiteral} '{' (entries+=MapEntryLiteral (',' entries+=MapEntryLiteral)*)? '}') | {MapLiteral} '{'
	//	BEGIN (entries+=MapEntryLiteral (BREAK entries+=MapEntryLiteral)*)?
	//	END
	//	'}';
	public MapLiteralElements getMapLiteralAccess() {
		return pMapLiteral;
	}
	
	public ParserRule getMapLiteralRule() {
		return getMapLiteralAccess().getRule();
	}
	
	//MapEntryLiteral:
	//	name=ID ':' value=Literal;
	public MapEntryLiteralElements getMapEntryLiteralAccess() {
		return pMapEntryLiteral;
	}
	
	public ParserRule getMapEntryLiteralRule() {
		return getMapEntryLiteralAccess().getRule();
	}
	
	//EnumLiteral:
	//	{EnumLiteral} ref=[EnumItemDef];
	public EnumLiteralElements getEnumLiteralAccess() {
		return pEnumLiteral;
	}
	
	public ParserRule getEnumLiteralRule() {
		return getEnumLiteralAccess().getRule();
	}
	
	//PatternLiteral:
	//	{PatternLiteral} (native=NativeDef | ref=[Definition]) '@' text=TEXT;
	public PatternLiteralElements getPatternLiteralAccess() {
		return pPatternLiteral;
	}
	
	public ParserRule getPatternLiteralRule() {
		return getPatternLiteralAccess().getRule();
	}
	
	//BREAK:
	//	('\n' | '\r')*;
	public BREAKElements getBREAKAccess() {
		return pBREAK;
	}
	
	public ParserRule getBREAKRule() {
		return getBREAKAccess().getRule();
	}
	
	//terminal BEGIN:
	//	'synthetic:BEGIN';
	public TerminalRule getBEGINRule() {
		return tBEGIN;
	}
	
	//terminal END:
	//	'synthetic:END';
	public TerminalRule getENDRule() {
		return tEND;
	}
	
	//terminal PATH:
	//	'/' ('a'..'z' | '-' | '0'..'9')+*;
	public TerminalRule getPATHRule() {
		return tPATH;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '-' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal INT:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal NATURAL:
	//	'-'? INT;
	public TerminalRule getNATURALRule() {
		return tNATURAL;
	}
	
	//terminal FLOAT:
	//	NATURAL ('.' INT)?;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal DATE:
	//	INT '-' ('0' '1'..'9' | '1' '0'..'2') '-' ('0' '1'..'9' | '1'..'2' '0'..'9' | '3' '0'..'1');
	public TerminalRule getDATERule() {
		return tDATE;
	}
	
	//terminal TIME:
	//	('0'..'1' '0'..'9' | '2' '0'..'3') ':' ('0'..'5' '0'..'9') ':' ('0'..'5' '0'..'9');
	public TerminalRule getTIMERule() {
		return tTIME;
	}
	
	//terminal DATETIME:
	//	DATE 'T' TIME;
	public TerminalRule getDATETIMERule() {
		return tDATETIME;
	}
	
	//terminal TEXT:
	//	"'" !("'" | '\r' | '\n')* "'" | '"""'->'"""';
	public TerminalRule getTEXTRule() {
		return tTEXT;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
