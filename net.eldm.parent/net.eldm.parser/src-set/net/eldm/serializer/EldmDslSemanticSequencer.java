/*
 * generated by Xtext 2.15.0
 */
package net.eldm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import net.eldm.eldmDsl.BlockExpression;
import net.eldm.eldmDsl.BoolLiteral;
import net.eldm.eldmDsl.Contract;
import net.eldm.eldmDsl.DateLiteral;
import net.eldm.eldmDsl.DateTimeLiteral;
import net.eldm.eldmDsl.EldmDslPackage;
import net.eldm.eldmDsl.ElementDef;
import net.eldm.eldmDsl.EnumDef;
import net.eldm.eldmDsl.EnumItemDef;
import net.eldm.eldmDsl.ExternalDef;
import net.eldm.eldmDsl.FltLiteral;
import net.eldm.eldmDsl.ForStatement;
import net.eldm.eldmDsl.Function;
import net.eldm.eldmDsl.IfStatement;
import net.eldm.eldmDsl.Import;
import net.eldm.eldmDsl.InferredDef;
import net.eldm.eldmDsl.IntLiteral;
import net.eldm.eldmDsl.IsExpression;
import net.eldm.eldmDsl.LambdaCall;
import net.eldm.eldmDsl.LambdaDef;
import net.eldm.eldmDsl.ListDef;
import net.eldm.eldmDsl.ListLiteral;
import net.eldm.eldmDsl.MapDef;
import net.eldm.eldmDsl.MapEntryDef;
import net.eldm.eldmDsl.MapEntryLiteral;
import net.eldm.eldmDsl.MapLiteral;
import net.eldm.eldmDsl.MemberCall;
import net.eldm.eldmDsl.Operation;
import net.eldm.eldmDsl.OperationDecl;
import net.eldm.eldmDsl.PathLiteral;
import net.eldm.eldmDsl.PatternLiteral;
import net.eldm.eldmDsl.PlugDsl;
import net.eldm.eldmDsl.Primary;
import net.eldm.eldmDsl.StrLiteral;
import net.eldm.eldmDsl.SubPath;
import net.eldm.eldmDsl.TemplateDef;
import net.eldm.eldmDsl.TimeLiteral;
import net.eldm.eldmDsl.TypeDef;
import net.eldm.eldmDsl.UnaryOperation;
import net.eldm.eldmDsl.ValueExpression;
import net.eldm.eldmDsl.Var;
import net.eldm.services.EldmDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EldmDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EldmDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EldmDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EldmDslPackage.BLOCK_EXPRESSION:
				sequence_BlockExpression(context, (BlockExpression) semanticObject); 
				return; 
			case EldmDslPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case EldmDslPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case EldmDslPackage.DATE_LITERAL:
				sequence_DateLiteral(context, (DateLiteral) semanticObject); 
				return; 
			case EldmDslPackage.DATE_TIME_LITERAL:
				sequence_DateTimeLiteral(context, (DateTimeLiteral) semanticObject); 
				return; 
			case EldmDslPackage.ELEMENT_DEF:
				sequence_ElementDef(context, (ElementDef) semanticObject); 
				return; 
			case EldmDslPackage.ENUM_DEF:
				sequence_EnumDef(context, (EnumDef) semanticObject); 
				return; 
			case EldmDslPackage.ENUM_ITEM_DEF:
				sequence_EnumItemDef(context, (EnumItemDef) semanticObject); 
				return; 
			case EldmDslPackage.EXTERNAL_DEF:
				sequence_ExternalDef(context, (ExternalDef) semanticObject); 
				return; 
			case EldmDslPackage.FLT_LITERAL:
				sequence_FltLiteral(context, (FltLiteral) semanticObject); 
				return; 
			case EldmDslPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case EldmDslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case EldmDslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case EldmDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case EldmDslPackage.INFERRED_DEF:
				sequence_InferredDef(context, (InferredDef) semanticObject); 
				return; 
			case EldmDslPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case EldmDslPackage.IS_EXPRESSION:
				sequence_RelationalExpression(context, (IsExpression) semanticObject); 
				return; 
			case EldmDslPackage.LAMBDA_CALL:
				sequence_LambdaCall(context, (LambdaCall) semanticObject); 
				return; 
			case EldmDslPackage.LAMBDA_DEF:
				sequence_LambdaDef(context, (LambdaDef) semanticObject); 
				return; 
			case EldmDslPackage.LIST_DEF:
				sequence_ListDef(context, (ListDef) semanticObject); 
				return; 
			case EldmDslPackage.LIST_LITERAL:
				sequence_ListLiteral(context, (ListLiteral) semanticObject); 
				return; 
			case EldmDslPackage.MAP_DEF:
				sequence_MapDef(context, (MapDef) semanticObject); 
				return; 
			case EldmDslPackage.MAP_ENTRY_DEF:
				sequence_MapEntryDef(context, (MapEntryDef) semanticObject); 
				return; 
			case EldmDslPackage.MAP_ENTRY_LITERAL:
				sequence_MapEntryLiteral(context, (MapEntryLiteral) semanticObject); 
				return; 
			case EldmDslPackage.MAP_LITERAL:
				sequence_MapLiteral(context, (MapLiteral) semanticObject); 
				return; 
			case EldmDslPackage.MEMBER_CALL:
				sequence_MemberCall(context, (MemberCall) semanticObject); 
				return; 
			case EldmDslPackage.MODULE:
				sequence_Module(context, (net.eldm.eldmDsl.Module) semanticObject); 
				return; 
			case EldmDslPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case EldmDslPackage.OPERATION_DECL:
				sequence_OperationDecl(context, (OperationDecl) semanticObject); 
				return; 
			case EldmDslPackage.PATH_LITERAL:
				sequence_PathLiteral(context, (PathLiteral) semanticObject); 
				return; 
			case EldmDslPackage.PATTERN_LITERAL:
				sequence_PatternLiteral(context, (PatternLiteral) semanticObject); 
				return; 
			case EldmDslPackage.PLUG_DSL:
				sequence_PlugDsl(context, (PlugDsl) semanticObject); 
				return; 
			case EldmDslPackage.PRIMARY:
				sequence_Primary(context, (Primary) semanticObject); 
				return; 
			case EldmDslPackage.STR_LITERAL:
				sequence_StrLiteral(context, (StrLiteral) semanticObject); 
				return; 
			case EldmDslPackage.SUB_PATH:
				sequence_SubPath(context, (SubPath) semanticObject); 
				return; 
			case EldmDslPackage.TEMPLATE_DEF:
				sequence_TemplateDef(context, (TemplateDef) semanticObject); 
				return; 
			case EldmDslPackage.TIME_LITERAL:
				sequence_TimeLiteral(context, (TimeLiteral) semanticObject); 
				return; 
			case EldmDslPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case EldmDslPackage.UNARY_OPERATION:
				sequence_UnaryOperation(context, (UnaryOperation) semanticObject); 
				return; 
			case EldmDslPackage.VALUE_EXPRESSION:
				if (rule == grammarAccess.getValueExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getValueExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_RelationalExpression(context, (ValueExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getValueExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(context, (ValueExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getValueExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(context, (ValueExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getIsExpressionLeftAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationalExpressionAccess().getValueExpressionLeftAction_1_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression(context, (ValueExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getValueExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (ValueExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getValueExpressionLeftAction_1_0_0_0()) {
					sequence_MultiplicativeExpression(context, (ValueExpression) semanticObject); 
					return; 
				}
				else break;
			case EldmDslPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ValueExpression returns ValueExpression
	 *     OrExpression returns ValueExpression
	 *     OrExpression.ValueExpression_1_0_0_0 returns ValueExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpression_ValueExpression_1_0_0_0 feature='or' right=AndExpression) | 
	 *         (left=AndExpression_ValueExpression_1_0_0_0 feature='and' right=EqualityExpression) | 
	 *         (left=EqualityExpression_ValueExpression_1_0_0_0 (feature='==' | feature='!=') right=RelationalExpression) | 
	 *         (left=RelationalExpression_ValueExpression_1_1_0_0_0 (feature='>=' | feature='<=' | feature='>' | feature='<') right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_ValueExpression_1_0_0_0 (feature='+' | feature='-' | feature='set' | feature='del') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_ValueExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_RelationalExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns ValueExpression
	 *     AndExpression.ValueExpression_1_0_0_0 returns ValueExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_ValueExpression_1_0_0_0 feature='and' right=EqualityExpression) | 
	 *         (left=EqualityExpression_ValueExpression_1_0_0_0 (feature='==' | feature='!=') right=RelationalExpression) | 
	 *         (left=RelationalExpression_ValueExpression_1_1_0_0_0 (feature='>=' | feature='<=' | feature='>' | feature='<') right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_ValueExpression_1_0_0_0 (feature='+' | feature='-' | feature='set' | feature='del') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_ValueExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression returns ValueExpression
	 *     EqualityExpression.ValueExpression_1_0_0_0 returns ValueExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=EqualityExpression_ValueExpression_1_0_0_0 (feature='==' | feature='!=') right=RelationalExpression) | 
	 *         (left=RelationalExpression_ValueExpression_1_1_0_0_0 (feature='>=' | feature='<=' | feature='>' | feature='<') right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_ValueExpression_1_0_0_0 (feature='+' | feature='-' | feature='set' | feature='del') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_ValueExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns ValueExpression
	 *     RelationalExpression.IsExpression_1_0_0_0_0 returns ValueExpression
	 *     RelationalExpression.ValueExpression_1_1_0_0_0 returns ValueExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=RelationalExpression_ValueExpression_1_1_0_0_0 (feature='>=' | feature='<=' | feature='>' | feature='<') right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_ValueExpression_1_0_0_0 (feature='+' | feature='-' | feature='set' | feature='del') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_ValueExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns ValueExpression
	 *     AdditiveExpression.ValueExpression_1_0_0_0 returns ValueExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AdditiveExpression_ValueExpression_1_0_0_0 (feature='+' | feature='-' | feature='set' | feature='del') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_ValueExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockExpression returns BlockExpression
	 *
	 * Constraint:
	 *     expressions+=Expression*
	 */
	protected void sequence_BlockExpression(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     ((flow='in' | flow='out') cond=ValueExpression msg=TEXT?)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns DateLiteral
	 *     DateLiteral returns DateLiteral
	 *
	 * Constraint:
	 *     value=DATE
	 */
	protected void sequence_DateLiteral(ISerializationContext context, DateLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.DATE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.DATE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateLiteralAccess().getValueDATETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns DateTimeLiteral
	 *     DateTimeLiteral returns DateTimeLiteral
	 *
	 * Constraint:
	 *     value=DATETIME
	 */
	protected void sequence_DateTimeLiteral(ISerializationContext context, DateTimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.DATE_TIME_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.DATE_TIME_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateTimeLiteralAccess().getValueDATETIMETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns ElementDef
	 *     ElementDef returns ElementDef
	 *
	 * Constraint:
	 *     ref=[Definition|ID]
	 */
	protected void sequence_ElementDef(ISerializationContext context, ElementDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.ELEMENT_DEF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.ELEMENT_DEF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementDefAccess().getRefDefinitionIDTerminalRuleCall_0_0_1(), semanticObject.eGet(EldmDslPackage.Literals.ELEMENT_DEF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns EnumDef
	 *     EnumDef returns EnumDef
	 *
	 * Constraint:
	 *     (type=MapDef? defs+=EnumItemDef+)
	 */
	protected void sequence_EnumDef(ISerializationContext context, EnumDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumItemDef returns EnumItemDef
	 *
	 * Constraint:
	 *     (name=ID value=MapLiteral?)
	 */
	protected void sequence_EnumItemDef(ISerializationContext context, EnumItemDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExternalDef returns ExternalDef
	 *     Definition returns ExternalDef
	 *
	 * Constraint:
	 *     ((ref=ID name=ID?) | name=ID)
	 */
	protected void sequence_ExternalDef(ISerializationContext context, ExternalDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns FltLiteral
	 *     FltLiteral returns FltLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FltLiteral(ISerializationContext context, FltLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.FLT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.FLT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFltLiteralAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ForStatement
	 *     FlowStatement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (flow='for' param=ID for=ValueExpression (each=ValueExpression | each=BlockExpression))
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID lambda=LambdaDef body=BlockExpression)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.FUNCTION__LAMBDA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.FUNCTION__LAMBDA));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.FUNCTION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.FUNCTION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionAccess().getLambdaLambdaDefParserRuleCall_2_0(), semanticObject.getLambda());
		feeder.accept(grammarAccess.getFunctionAccess().getBodyBlockExpressionParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfStatement
	 *     FlowStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (flow='if' cond=ValueExpression (then=ValueExpression | then=BlockExpression) (else=ValueExpression | else=BlockExpression)?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     ((path=PathLiteral | (defs+=ExternalDef defs+=ExternalDef*)) ref=PathLiteral)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns InferredDef
	 *     ElementDef returns InferredDef
	 *     InferredDef returns InferredDef
	 *
	 * Constraint:
	 *     native=NativeDef
	 */
	protected void sequence_InferredDef(ISerializationContext context, InferredDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.INFERRED_DEF__NATIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.INFERRED_DEF__NATIVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInferredDefAccess().getNativeNativeDefParserRuleCall_0_0(), semanticObject.getNative());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=NATURAL
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueNATURALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LambdaCall returns LambdaCall
	 *
	 * Constraint:
	 *     (param=ID? exp=ValueExpression)
	 */
	protected void sequence_LambdaCall(ISerializationContext context, LambdaCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns LambdaDef
	 *     ElementDef returns LambdaDef
	 *     InferredDef returns LambdaDef
	 *     LambdaDef returns LambdaDef
	 *
	 * Constraint:
	 *     (param=ElementDef result=ElementDef?)?
	 */
	protected void sequence_LambdaDef(ISerializationContext context, LambdaDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns ListDef
	 *     ElementDef returns ListDef
	 *     InferredDef returns ListDef
	 *     ListDef returns ListDef
	 *
	 * Constraint:
	 *     ((ext='I' | ext='S' | ext='L') type=ElementDef)
	 */
	protected void sequence_ListDef(ISerializationContext context, ListDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns ListLiteral
	 *     ListLiteral returns ListLiteral
	 *
	 * Constraint:
	 *     (vals+=Literal vals+=Literal*)?
	 */
	protected void sequence_ListLiteral(ISerializationContext context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns MapDef
	 *     ElementDef returns MapDef
	 *     InferredDef returns MapDef
	 *     MapDef returns MapDef
	 *
	 * Constraint:
	 *     (((defs+=MapEntryDef defs+=MapEntryDef*)? ext?='?'?) | ((defs+=MapEntryDef defs+=MapEntryDef*)? ext?='?'?))
	 */
	protected void sequence_MapDef(ISerializationContext context, MapDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryDef returns MapEntryDef
	 *
	 * Constraint:
	 *     (name=ID ((opt?='?'? type=ElementDef) | (opt?='=' value=Literal))?)
	 */
	protected void sequence_MapEntryDef(ISerializationContext context, MapEntryDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryLiteral returns MapEntryLiteral
	 *
	 * Constraint:
	 *     (name=ID value=Literal)
	 */
	protected void sequence_MapEntryLiteral(ISerializationContext context, MapEntryLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryLiteralAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapEntryLiteralAccess().getValueLiteralParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns MapLiteral
	 *     MapLiteral returns MapLiteral
	 *
	 * Constraint:
	 *     ((entries+=MapEntryLiteral entries+=MapEntryLiteral*) | (entries+=MapEntryLiteral entries+=MapEntryLiteral*))?
	 */
	protected void sequence_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberCall returns MemberCall
	 *
	 * Constraint:
	 *     ((unknown?='?.'? member=ID lambda=LambdaCall?) | key=ValueExpression)
	 */
	protected void sequence_MemberCall(ISerializationContext context, MemberCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (
	 *         name=PathLiteral 
	 *         imports+=Import* 
	 *         plugs+=PlugDsl* 
	 *         defs+=Definition* 
	 *         vars+=Var* 
	 *         funcs+=Function* 
	 *         opers+=Operation* 
	 *         paths+=SubPath*
	 *     )
	 */
	protected void sequence_Module(ISerializationContext context, net.eldm.eldmDsl.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns ValueExpression
	 *     MultiplicativeExpression.ValueExpression_1_0_0_0 returns ValueExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_ValueExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationDecl returns OperationDecl
	 *
	 * Constraint:
	 *     (
	 *         (type='catch' param=ElementDef?) | 
	 *         (
	 *             contracts+=Contract* 
	 *             type='def' 
	 *             srv?='service'? 
	 *             get?='get'? 
	 *             path=PathLiteral? 
	 *             param=ElementDef? 
	 *             result=ElementDef?
	 *         )
	 *     )
	 */
	protected void sequence_OperationDecl(ISerializationContext context, OperationDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (decl=OperationDecl body=BlockExpression)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.OPERATION__DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.OPERATION__DECL));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.OPERATION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.OPERATION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperationAccess().getDeclOperationDeclParserRuleCall_0_0(), semanticObject.getDecl());
		feeder.accept(grammarAccess.getOperationAccess().getBodyBlockExpressionParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns PathLiteral
	 *     PathLiteral returns PathLiteral
	 *
	 * Constraint:
	 *     value=PATH
	 */
	protected void sequence_PathLiteral(ISerializationContext context, PathLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.PATH_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.PATH_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathLiteralAccess().getValuePATHTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns PatternLiteral
	 *     PatternLiteral returns PatternLiteral
	 *
	 * Constraint:
	 *     ((native=NativeDef | ref=[Definition|ID]) text=TEXT)
	 */
	protected void sequence_PatternLiteral(ISerializationContext context, PatternLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlugDsl returns PlugDsl
	 *
	 * Constraint:
	 *     (name=ID ref=PathLiteral)
	 */
	protected void sequence_PlugDsl(ISerializationContext context, PlugDsl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.PLUG_DSL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.PLUG_DSL__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.PLUG_DSL__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.PLUG_DSL__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlugDslAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPlugDslAccess().getRefPathLiteralParserRuleCall_3_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValueExpression returns Primary
	 *     OrExpression returns Primary
	 *     OrExpression.ValueExpression_1_0_0_0 returns Primary
	 *     AndExpression returns Primary
	 *     AndExpression.ValueExpression_1_0_0_0 returns Primary
	 *     EqualityExpression returns Primary
	 *     EqualityExpression.ValueExpression_1_0_0_0 returns Primary
	 *     RelationalExpression returns Primary
	 *     RelationalExpression.IsExpression_1_0_0_0_0 returns Primary
	 *     RelationalExpression.ValueExpression_1_1_0_0_0 returns Primary
	 *     AdditiveExpression returns Primary
	 *     AdditiveExpression.ValueExpression_1_0_0_0 returns Primary
	 *     MultiplicativeExpression returns Primary
	 *     MultiplicativeExpression.ValueExpression_1_0_0_0 returns Primary
	 *     UnaryOperation returns Primary
	 *     Primary returns Primary
	 *
	 * Constraint:
	 *     (value=Literal | ((cast?='Â«' type=ElementDef)? (ref=ID | exp=ValueExpression) calls+=MemberCall*))
	 */
	protected void sequence_Primary(ISerializationContext context, Primary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueExpression returns IsExpression
	 *     OrExpression returns IsExpression
	 *     OrExpression.ValueExpression_1_0_0_0 returns IsExpression
	 *     AndExpression returns IsExpression
	 *     AndExpression.ValueExpression_1_0_0_0 returns IsExpression
	 *     EqualityExpression returns IsExpression
	 *     EqualityExpression.ValueExpression_1_0_0_0 returns IsExpression
	 *     RelationalExpression returns IsExpression
	 *     RelationalExpression.IsExpression_1_0_0_0_0 returns IsExpression
	 *     RelationalExpression.ValueExpression_1_1_0_0_0 returns IsExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression_IsExpression_1_0_0_0_0 feature='is' type=ElementDef)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, IsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.VALUE_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.VALUE_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.VALUE_EXPRESSION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.VALUE_EXPRESSION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.IS_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.IS_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getIsExpressionLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getFeatureIsKeyword_1_0_0_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getTypeElementDefParserRuleCall_1_0_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns StrLiteral
	 *     StrLiteral returns StrLiteral
	 *
	 * Constraint:
	 *     value=TEXT
	 */
	protected void sequence_StrLiteral(ISerializationContext context, StrLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.STR_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.STR_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrLiteralAccess().getValueTEXTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubPath returns SubPath
	 *
	 * Constraint:
	 *     (path=PathLiteral funcs+=Operation+)
	 */
	protected void sequence_SubPath(ISerializationContext context, SubPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopDef returns TemplateDef
	 *     ElementDef returns TemplateDef
	 *     InferredDef returns TemplateDef
	 *     TemplateDef returns TemplateDef
	 *
	 * Constraint:
	 *     (type=ElementDef | name=ID)
	 */
	protected void sequence_TemplateDef(ISerializationContext context, TemplateDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns TimeLiteral
	 *     TimeLiteral returns TimeLiteral
	 *
	 * Constraint:
	 *     value=TIME
	 */
	protected void sequence_TimeLiteral(ISerializationContext context, TimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.TIME_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.TIME_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeLiteralAccess().getValueTIMETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns TypeDef
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=ID (((parser='match' | parser='mask') code=TEXT) | type=TopDef))
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueExpression returns UnaryOperation
	 *     OrExpression returns UnaryOperation
	 *     OrExpression.ValueExpression_1_0_0_0 returns UnaryOperation
	 *     AndExpression returns UnaryOperation
	 *     AndExpression.ValueExpression_1_0_0_0 returns UnaryOperation
	 *     EqualityExpression returns UnaryOperation
	 *     EqualityExpression.ValueExpression_1_0_0_0 returns UnaryOperation
	 *     RelationalExpression returns UnaryOperation
	 *     RelationalExpression.IsExpression_1_0_0_0_0 returns UnaryOperation
	 *     RelationalExpression.ValueExpression_1_1_0_0_0 returns UnaryOperation
	 *     AdditiveExpression returns UnaryOperation
	 *     AdditiveExpression.ValueExpression_1_0_0_0 returns UnaryOperation
	 *     MultiplicativeExpression returns UnaryOperation
	 *     MultiplicativeExpression.ValueExpression_1_0_0_0 returns UnaryOperation
	 *     UnaryOperation returns UnaryOperation
	 *
	 * Constraint:
	 *     (feature='!' operand=UnaryOperation)
	 */
	protected void sequence_UnaryOperation(ISerializationContext context, UnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.VALUE_EXPRESSION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.VALUE_EXPRESSION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.UNARY_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.UNARY_OPERATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryOperationAccess().getFeatureExclamationMarkKeyword_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getUnaryOperationAccess().getOperandUnaryOperationParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (let?='let'? name=ID type=ElementDef? result=ValueExpression)
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
