/*
 * generated by Xtext 2.15.0
 */
package net.eldm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import net.eldm.eldmDsl.BlockExpression;
import net.eldm.eldmDsl.BoolLiteral;
import net.eldm.eldmDsl.DateLiteral;
import net.eldm.eldmDsl.DateTimeLiteral;
import net.eldm.eldmDsl.EldmDslPackage;
import net.eldm.eldmDsl.ElementDef;
import net.eldm.eldmDsl.EnumDef;
import net.eldm.eldmDsl.EnumItemDef;
import net.eldm.eldmDsl.EnumLiteral;
import net.eldm.eldmDsl.ExternalDef;
import net.eldm.eldmDsl.FltLiteral;
import net.eldm.eldmDsl.Import;
import net.eldm.eldmDsl.InstanceOfExpression;
import net.eldm.eldmDsl.IntLiteral;
import net.eldm.eldmDsl.Let;
import net.eldm.eldmDsl.ListDef;
import net.eldm.eldmDsl.ListLiteral;
import net.eldm.eldmDsl.MapDef;
import net.eldm.eldmDsl.MapEntryDef;
import net.eldm.eldmDsl.MapEntryLiteral;
import net.eldm.eldmDsl.MapLiteral;
import net.eldm.eldmDsl.MemberGet;
import net.eldm.eldmDsl.Operation;
import net.eldm.eldmDsl.ParamDef;
import net.eldm.eldmDsl.PathLiteral;
import net.eldm.eldmDsl.PatternLiteral;
import net.eldm.eldmDsl.PlugDsl;
import net.eldm.eldmDsl.PostfixOperation;
import net.eldm.eldmDsl.ResultExpression;
import net.eldm.eldmDsl.StrLiteral;
import net.eldm.eldmDsl.SubPath;
import net.eldm.eldmDsl.TimeLiteral;
import net.eldm.eldmDsl.TypeDef;
import net.eldm.services.EldmDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EldmDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EldmDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EldmDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EldmDslPackage.BLOCK_EXPRESSION:
				sequence_BlockExpression(context, (BlockExpression) semanticObject); 
				return; 
			case EldmDslPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case EldmDslPackage.DATE_LITERAL:
				sequence_DateLiteral(context, (DateLiteral) semanticObject); 
				return; 
			case EldmDslPackage.DATE_TIME_LITERAL:
				sequence_DateTimeLiteral(context, (DateTimeLiteral) semanticObject); 
				return; 
			case EldmDslPackage.ELEMENT_DEF:
				sequence_ElementDef(context, (ElementDef) semanticObject); 
				return; 
			case EldmDslPackage.ENUM_DEF:
				sequence_EnumDef(context, (EnumDef) semanticObject); 
				return; 
			case EldmDslPackage.ENUM_ITEM_DEF:
				sequence_EnumItemDef(context, (EnumItemDef) semanticObject); 
				return; 
			case EldmDslPackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case EldmDslPackage.EXTERNAL_DEF:
				sequence_ExternalDef(context, (ExternalDef) semanticObject); 
				return; 
			case EldmDslPackage.FLT_LITERAL:
				sequence_FltLiteral(context, (FltLiteral) semanticObject); 
				return; 
			case EldmDslPackage.IMPORT:
				if (rule == grammarAccess.getImportDefinitionRule()) {
					sequence_ImportDefinition(context, (Import) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImportRule()) {
					sequence_ImportDefinition_ImportOperation(context, (Import) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImportOperationRule()) {
					sequence_ImportOperation(context, (Import) semanticObject); 
					return; 
				}
				else break;
			case EldmDslPackage.INSTANCE_OF_EXPRESSION:
				sequence_RelationalExpression(context, (InstanceOfExpression) semanticObject); 
				return; 
			case EldmDslPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case EldmDslPackage.LET:
				sequence_Let(context, (Let) semanticObject); 
				return; 
			case EldmDslPackage.LIST_DEF:
				sequence_ListDef(context, (ListDef) semanticObject); 
				return; 
			case EldmDslPackage.LIST_LITERAL:
				sequence_ListLiteral(context, (ListLiteral) semanticObject); 
				return; 
			case EldmDslPackage.MAP_DEF:
				sequence_MapDef(context, (MapDef) semanticObject); 
				return; 
			case EldmDslPackage.MAP_ENTRY_DEF:
				sequence_MapEntryDef(context, (MapEntryDef) semanticObject); 
				return; 
			case EldmDslPackage.MAP_ENTRY_LITERAL:
				sequence_MapEntryLiteral(context, (MapEntryLiteral) semanticObject); 
				return; 
			case EldmDslPackage.MAP_LITERAL:
				sequence_MapLiteral(context, (MapLiteral) semanticObject); 
				return; 
			case EldmDslPackage.MEMBER_GET:
				sequence_MemberGet(context, (MemberGet) semanticObject); 
				return; 
			case EldmDslPackage.MODULE:
				sequence_Module(context, (net.eldm.eldmDsl.Module) semanticObject); 
				return; 
			case EldmDslPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case EldmDslPackage.PARAM_DEF:
				sequence_ParamDef(context, (ParamDef) semanticObject); 
				return; 
			case EldmDslPackage.PATH_LITERAL:
				sequence_PathLiteral(context, (PathLiteral) semanticObject); 
				return; 
			case EldmDslPackage.PATTERN_LITERAL:
				sequence_PatternLiteral(context, (PatternLiteral) semanticObject); 
				return; 
			case EldmDslPackage.PLUG_DSL:
				sequence_PlugDsl(context, (PlugDsl) semanticObject); 
				return; 
			case EldmDslPackage.POSTFIX_OPERATION:
				sequence_PostfixOperation(context, (PostfixOperation) semanticObject); 
				return; 
			case EldmDslPackage.RESULT_EXPRESSION:
				if (rule == grammarAccess.getResultExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getResultExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getResultExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getResultExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationalExpressionAccess().getResultExpressionLeftAction_1_1_0_0_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getResultExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getResultExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getUnaryOperationRule()
						|| rule == grammarAccess.getPostfixOperationRule()
						|| action == grammarAccess.getPostfixOperationAccess().getPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getBaseExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_Primary_RelationalExpression_UnaryOperation(context, (ResultExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryRule()) {
					sequence_Primary(context, (ResultExpression) semanticObject); 
					return; 
				}
				else break;
			case EldmDslPackage.STR_LITERAL:
				sequence_StrLiteral(context, (StrLiteral) semanticObject); 
				return; 
			case EldmDslPackage.SUB_PATH:
				sequence_SubPath(context, (SubPath) semanticObject); 
				return; 
			case EldmDslPackage.TIME_LITERAL:
				sequence_TimeLiteral(context, (TimeLiteral) semanticObject); 
				return; 
			case EldmDslPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ResultExpression returns ResultExpression
	 *     OrExpression returns ResultExpression
	 *     OrExpression.ResultExpression_1_0_0_0 returns ResultExpression
	 *     AndExpression returns ResultExpression
	 *     AndExpression.ResultExpression_1_0_0_0 returns ResultExpression
	 *     EqualityExpression returns ResultExpression
	 *     EqualityExpression.ResultExpression_1_0_0_0 returns ResultExpression
	 *     RelationalExpression returns ResultExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns ResultExpression
	 *     RelationalExpression.ResultExpression_1_1_0_0_0 returns ResultExpression
	 *     AdditiveExpression returns ResultExpression
	 *     AdditiveExpression.ResultExpression_1_0_0_0 returns ResultExpression
	 *     MultiplicativeExpression returns ResultExpression
	 *     MultiplicativeExpression.ResultExpression_1_0_0_0 returns ResultExpression
	 *     UnaryOperation returns ResultExpression
	 *     PostfixOperation returns ResultExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ResultExpression
	 *     BaseExpression returns ResultExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpression_ResultExpression_1_0_0_0 feature='|' right=OrExpression) | 
	 *         (left=AndExpression_ResultExpression_1_0_0_0 feature='&' right=EqualityExpression) | 
	 *         (left=EqualityExpression_ResultExpression_1_0_0_0 (feature='==' | feature='!=') right=RelationalExpression) | 
	 *         (left=RelationalExpression_ResultExpression_1_1_0_0_0 (feature='>=' | feature='<=' | feature='>' | feature='<') right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_ResultExpression_1_0_0_0 (feature='+' | feature='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_ResultExpression_1_0_0_0 (feature='*' | feature='**' | feature='/' | feature='%') right=UnaryOperation) | 
	 *         ((feature='!' | feature='+' | feature='-') operand=UnaryOperation) | 
	 *         value=Literal | 
	 *         (target=[Let|ID] members+=MemberGet*)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_Primary_RelationalExpression_UnaryOperation(ISerializationContext context, ResultExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockExpression returns BlockExpression
	 *
	 * Constraint:
	 *     expressions+=Expression*
	 */
	protected void sequence_BlockExpression(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     isTrue?='true'?
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns DateLiteral
	 *     DateLiteral returns DateLiteral
	 *
	 * Constraint:
	 *     value=DATE
	 */
	protected void sequence_DateLiteral(ISerializationContext context, DateLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.DATE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.DATE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateLiteralAccess().getValueDATETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns DateTimeLiteral
	 *     DateTimeLiteral returns DateTimeLiteral
	 *
	 * Constraint:
	 *     value=DATETIME
	 */
	protected void sequence_DateTimeLiteral(ISerializationContext context, DateTimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.DATE_TIME_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.DATE_TIME_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateTimeLiteralAccess().getValueDATETIMETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ElementDef
	 *
	 * Constraint:
	 *     (native=NativeDef | ref=[Definition|ID])
	 */
	protected void sequence_ElementDef(ISerializationContext context, ElementDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns EnumDef
	 *     EnumDef returns EnumDef
	 *
	 * Constraint:
	 *     (type=MapDef? defs+=EnumItemDef+)
	 */
	protected void sequence_EnumDef(ISerializationContext context, EnumDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumItemDef returns EnumItemDef
	 *
	 * Constraint:
	 *     (name=ID value=MapLiteral?)
	 */
	protected void sequence_EnumItemDef(ISerializationContext context, EnumItemDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns EnumLiteral
	 *     EnumLiteral returns EnumLiteral
	 *
	 * Constraint:
	 *     ref=[EnumItemDef|ID]
	 */
	protected void sequence_EnumLiteral(ISerializationContext context, EnumLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.ENUM_LITERAL__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.ENUM_LITERAL__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralAccess().getRefEnumItemDefIDTerminalRuleCall_2_0_1(), semanticObject.eGet(EldmDslPackage.Literals.ENUM_LITERAL__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExternalDef returns ExternalDef
	 *     Definition returns ExternalDef
	 *
	 * Constraint:
	 *     ((ref=ID name=ID?) | name=ID)
	 */
	protected void sequence_ExternalDef(ISerializationContext context, ExternalDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns FltLiteral
	 *     FltLiteral returns FltLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FltLiteral(ISerializationContext context, FltLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.FLT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.FLT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFltLiteralAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportDefinition returns Import
	 *
	 * Constraint:
	 *     (defs+=ExternalDef defs+=ExternalDef* ref=PathLiteral)
	 */
	protected void sequence_ImportDefinition(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     ((name=PathLiteral ref=PathLiteral) | (defs+=ExternalDef defs+=ExternalDef* ref=PathLiteral))
	 */
	protected void sequence_ImportDefinition_ImportOperation(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportOperation returns Import
	 *
	 * Constraint:
	 *     (name=PathLiteral ref=PathLiteral)
	 */
	protected void sequence_ImportOperation(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.IMPORT__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.IMPORT__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportOperationAccess().getNamePathLiteralParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getImportOperationAccess().getRefPathLiteralParserRuleCall_2_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=NATURAL
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueNATURALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Let
	 *     Let returns Let
	 *
	 * Constraint:
	 *     (name=ID result=ResultExpression)
	 */
	protected void sequence_Let(ISerializationContext context, Let semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.LET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.LET__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.LET__RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.LET__RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetAccess().getResultResultExpressionParserRuleCall_4_0(), semanticObject.getResult());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns ListDef
	 *     ListDef returns ListDef
	 *
	 * Constraint:
	 *     type=ElementDef
	 */
	protected void sequence_ListDef(ISerializationContext context, ListDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.LIST_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.LIST_DEF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListDefAccess().getTypeElementDefParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns ListLiteral
	 *     ListLiteral returns ListLiteral
	 *
	 * Constraint:
	 *     (vals+=Literal vals+=Literal*)?
	 */
	protected void sequence_ListLiteral(ISerializationContext context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementDef returns MapDef
	 *     MapDef returns MapDef
	 *
	 * Constraint:
	 *     ((defs+=MapEntryDef defs+=MapEntryDef*) | (defs+=MapEntryDef defs+=MapEntryDef*))?
	 */
	protected void sequence_MapDef(ISerializationContext context, MapDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryDef returns MapEntryDef
	 *
	 * Constraint:
	 *     (name=ID ((opt?='?'? type=ElementDef) | value=Literal))
	 */
	protected void sequence_MapEntryDef(ISerializationContext context, MapEntryDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntryLiteral returns MapEntryLiteral
	 *
	 * Constraint:
	 *     (name=ID value=Literal)
	 */
	protected void sequence_MapEntryLiteral(ISerializationContext context, MapEntryLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.MAP_ENTRY_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryLiteralAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapEntryLiteralAccess().getValueLiteralParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns MapLiteral
	 *     MapLiteral returns MapLiteral
	 *
	 * Constraint:
	 *     ((entries+=MapEntryLiteral entries+=MapEntryLiteral*) | (entries+=MapEntryLiteral entries+=MapEntryLiteral*))?
	 */
	protected void sequence_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberGet returns MemberGet
	 *
	 * Constraint:
	 *     (isNullSafe?='?.'? member=ID)
	 */
	protected void sequence_MemberGet(ISerializationContext context, MemberGet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (
	 *         name=PathLiteral 
	 *         imports+=Import* 
	 *         plugs+=PlugDsl* 
	 *         defs+=Definition* 
	 *         valDefs+=Let* 
	 *         opers+=Operation* 
	 *         paths+=SubPath*
	 *     )
	 */
	protected void sequence_Module(ISerializationContext context, net.eldm.eldmDsl.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         isPrivate?='private'? 
	 *         isGet?='get'? 
	 *         name=PathLiteral? 
	 *         param=ParamDef? 
	 *         result=ElementDef? 
	 *         body=BlockExpression
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamDef returns ParamDef
	 *
	 * Constraint:
	 *     (def=MapDef | ref=[MapDef|ID])
	 */
	protected void sequence_ParamDef(ISerializationContext context, ParamDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns PathLiteral
	 *     PathLiteral returns PathLiteral
	 *
	 * Constraint:
	 *     value=PATH
	 */
	protected void sequence_PathLiteral(ISerializationContext context, PathLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.PATH_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.PATH_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathLiteralAccess().getValuePATHTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns PatternLiteral
	 *     PatternLiteral returns PatternLiteral
	 *
	 * Constraint:
	 *     ((native=NativeDef | ref=[Definition|ID]) text=TEXT)
	 */
	protected void sequence_PatternLiteral(ISerializationContext context, PatternLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlugDsl returns PlugDsl
	 *
	 * Constraint:
	 *     (name=ID adaptor=PatternLiteral)
	 */
	protected void sequence_PlugDsl(ISerializationContext context, PlugDsl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.PLUG_DSL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.PLUG_DSL__NAME));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.PLUG_DSL__ADAPTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.PLUG_DSL__ADAPTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlugDslAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPlugDslAccess().getAdaptorPatternLiteralParserRuleCall_2_0(), semanticObject.getAdaptor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ResultExpression returns PostfixOperation
	 *     OrExpression returns PostfixOperation
	 *     OrExpression.ResultExpression_1_0_0_0 returns PostfixOperation
	 *     AndExpression returns PostfixOperation
	 *     AndExpression.ResultExpression_1_0_0_0 returns PostfixOperation
	 *     EqualityExpression returns PostfixOperation
	 *     EqualityExpression.ResultExpression_1_0_0_0 returns PostfixOperation
	 *     RelationalExpression returns PostfixOperation
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns PostfixOperation
	 *     RelationalExpression.ResultExpression_1_1_0_0_0 returns PostfixOperation
	 *     AdditiveExpression returns PostfixOperation
	 *     AdditiveExpression.ResultExpression_1_0_0_0 returns PostfixOperation
	 *     MultiplicativeExpression returns PostfixOperation
	 *     MultiplicativeExpression.ResultExpression_1_0_0_0 returns PostfixOperation
	 *     UnaryOperation returns PostfixOperation
	 *     PostfixOperation returns PostfixOperation
	 *     PostfixOperation.PostfixOperation_1_0_0 returns PostfixOperation
	 *     BaseExpression returns PostfixOperation
	 *
	 * Constraint:
	 *     (operand=PostfixOperation_PostfixOperation_1_0_0 (feature='++' | feature='--'))
	 */
	protected void sequence_PostfixOperation(ISerializationContext context, PostfixOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns ResultExpression
	 *
	 * Constraint:
	 *     (value=Literal | (target=[Let|ID] members+=MemberGet*))
	 */
	protected void sequence_Primary(ISerializationContext context, ResultExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResultExpression returns InstanceOfExpression
	 *     OrExpression returns InstanceOfExpression
	 *     OrExpression.ResultExpression_1_0_0_0 returns InstanceOfExpression
	 *     AndExpression returns InstanceOfExpression
	 *     AndExpression.ResultExpression_1_0_0_0 returns InstanceOfExpression
	 *     EqualityExpression returns InstanceOfExpression
	 *     EqualityExpression.ResultExpression_1_0_0_0 returns InstanceOfExpression
	 *     RelationalExpression returns InstanceOfExpression
	 *     RelationalExpression.InstanceOfExpression_1_0_0_0_0 returns InstanceOfExpression
	 *     RelationalExpression.ResultExpression_1_1_0_0_0 returns InstanceOfExpression
	 *     AdditiveExpression returns InstanceOfExpression
	 *     AdditiveExpression.ResultExpression_1_0_0_0 returns InstanceOfExpression
	 *     MultiplicativeExpression returns InstanceOfExpression
	 *     MultiplicativeExpression.ResultExpression_1_0_0_0 returns InstanceOfExpression
	 *     UnaryOperation returns InstanceOfExpression
	 *     PostfixOperation returns InstanceOfExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns InstanceOfExpression
	 *     BaseExpression returns InstanceOfExpression
	 *
	 * Constraint:
	 *     (expression=RelationalExpression_InstanceOfExpression_1_0_0_0_0 type=ElementDef)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, InstanceOfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.INSTANCE_OF_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.INSTANCE_OF_EXPRESSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.INSTANCE_OF_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.INSTANCE_OF_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0_0_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getTypeElementDefParserRuleCall_1_0_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns StrLiteral
	 *     StrLiteral returns StrLiteral
	 *
	 * Constraint:
	 *     value=TEXT
	 */
	protected void sequence_StrLiteral(ISerializationContext context, StrLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.STR_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.STR_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrLiteralAccess().getValueTEXTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubPath returns SubPath
	 *
	 * Constraint:
	 *     (name=PathLiteral opers+=Operation+)
	 */
	protected void sequence_SubPath(ISerializationContext context, SubPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns TimeLiteral
	 *     TimeLiteral returns TimeLiteral
	 *
	 * Constraint:
	 *     value=TIME
	 */
	protected void sequence_TimeLiteral(ISerializationContext context, TimeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EldmDslPackage.Literals.TIME_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EldmDslPackage.Literals.TIME_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeLiteralAccess().getValueTIMETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns TypeDef
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=ID (((parser='match' | parser='mask') code=TEXT) | type=ElementDef))
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
